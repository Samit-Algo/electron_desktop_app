<!-- Chatbot Styles -->
<style>
  /* Chatbot Grid Layout States */
  body.chatbot-open {
    grid-template-columns: 
      var(--phoenix-navbar-vertical-width, 280px)
      1fr
      var(--chatbot-width, 400px);
  }
  
  body.chatbot-expanded {
    grid-template-columns: 
      var(--phoenix-navbar-vertical-width, 280px)
      1fr
      var(--chatbot-width, 400px);
  }
  
  /* When chatbot is expanded (>400px), keep content width as if chatbot were 400px.
     The viewport (middle column) is narrower, so horizontal scroll reveals the
     "extra hidden" area without creating empty margin space. */
  .viewport-scrolls.chatbot-expanded .content {
    min-width: calc(100% + var(--chatbot-excess, 0px));
  }
  
  /* Chatbot panel - Column 3 */
  #chatbot-offcanvas {
    grid-column: 3;
    grid-row: 2;
    position: relative !important;
    transform: none !important;
    visibility: visible !important;
    background-color: var(--phoenix-body-bg, #fff);
    border-left: 1px solid var(--phoenix-border-color, #e9ecef);
    box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
    z-index: 1045;
    min-width: 300px;
    max-width: 1200px;
    transition: width 0.2s ease;
    display: none;
    height: 100%;
    min-height: 0;
    /* IMPORTANT: prevent the entire panel from scrolling.
       Only the messages area should scroll so the input stays pinned. */
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  
  #chatbot-offcanvas.show {
    display: block !important;
  }

  /* Make header/body/footer a proper fixed layout inside the offcanvas */
  #chatbot-offcanvas .offcanvas-header {
    flex: 0 0 auto;
  }
  #chatbot-offcanvas .offcanvas-body {
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    padding: 0 !important;
  }
  #chatbot-offcanvas .chat {
    flex: 1 1 auto;
    min-height: 0;
    display: flex;
    flex-direction: column;
  }
  #chatbot-offcanvas .chat-messages {
    flex: 1 1 auto;
    min-height: 0;
    overflow-y: auto;
    overflow-x: hidden;
  }
  #chatbot-offcanvas .card-footer {
    flex: 0 0 auto;
    /* Let the flex layout pin the footer; avoids sticky reflow issues when textarea height changes */
    position: relative;
    background: var(--phoenix-body-bg, #fff);
    z-index: 2;
  }
  
  [dir="rtl"] #chatbot-offcanvas {
    border-left: none;
    border-right: 1px solid var(--phoenix-border-color, #e9ecef);
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
  }
  
  /* Hide Bootstrap offcanvas backdrop */
  .offcanvas-backdrop {
    display: none !important;
  }
  
  /* Chatbot input (textarea) */
  #chatbot-input {
    resize: none;
    overflow-y: auto; /* scroll after max lines */
    line-height: 1.4;
    max-height: 96px; /* ~4 lines (JS autosize also enforces) */
  }
  
  /* Viewport horizontal scroll when chatbot expanded */
  .viewport-scrolls.chatbot-expanded {
    overflow-x: auto;
  }
  
  /* Chatbot Resize Handle */
  .chatbot-resize-handle {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 8px;
    cursor: col-resize;
    z-index: 1051;
    background: transparent;
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
  }
  
  [dir="rtl"] .chatbot-resize-handle {
    left: auto;
    right: 0;
  }
  
  body.chatbot-resizing {
    cursor: col-resize !important;
    user-select: none !important;
  }
  
  body.chatbot-resizing * {
    cursor: col-resize !important;
  }

  /* Disable layout transitions while resizing to prevent "shaking" */
  body.chatbot-resizing {
    transition: none !important; /* stops grid-template-columns animation on body */
  }

  body.chatbot-resizing #chatbot-offcanvas,
  body.chatbot-resizing .viewport-scrolls,
  body.chatbot-resizing .content {
    transition: none !important; /* stops width/min-width animations while dragging */
  }
  
  .chatbot-resize-handle:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }
  
  .chatbot-resize-handle:active {
    background-color: rgba(0, 0, 0, 0.1);
  }
  
  .resize-handle-line {
    width: 2px;
    height: 40px;
    background-color: var(--phoenix-border-color, #e9ecef);
    border-radius: 2px;
    transition: background-color 0.2s ease;
  }
  
  .chatbot-resize-handle:hover .resize-handle-line {
    background-color: var(--phoenix-primary, #2A7BE4);
  }
  
  /* Ensure body doesn't get overflow hidden from Bootstrap */
  body.modal-open:has(#chatbot-offcanvas.show) {
    overflow: hidden !important;
    padding-right: 0 !important;
  }

  /* -----------------------------
     Chat header tabs (Phoenix/Bootstrap)
     ----------------------------- */
  #chatbot-offcanvas .chatbot-tabs {
    overflow-x: auto;
    white-space: nowrap;
    scrollbar-width: thin;
  }
  #chatbot-offcanvas .chatbot-tabs .nav-link {
    display: inline-flex;
    align-items: center;
  }
  #chatbot-offcanvas .chatbot-tab-name {
    max-width: 180px;
  }
  #chatbot-offcanvas .chatbot-tab-close {
    opacity: 0;
    pointer-events: none;
  }
  #chatbot-offcanvas .nav-item:hover .chatbot-tab-close {
    opacity: 1;
    pointer-events: auto;
  }

  /* Remove inline styles by mapping to classes */
  #chatbot-offcanvas .card-body.chat {
    min-height: 0;
  }
  .setting-toggle {
    margin-top: -120px;
  }
  .chatbot-toggle-icon {
    height: 34px;
    width: 28px;
  }

  /* Bottom composer: rectangular single container */
  #chatbot-offcanvas .chatbot-composer {
    border-radius: var(--phoenix-border-radius, 0.375rem);
  }
  #chatbot-offcanvas .chatbot-composer textarea.form-control {
    background: transparent;
  }
  /* When composer is flex-column-reverse, textarea grows upward and controls stay pinned */
  #chatbot-offcanvas .chatbot-composer {
    display: flex;
    flex-direction: column-reverse;
    gap: 0.5rem;
  }

  /* -----------------------------
     Markdown rendering inside assistant bubbles
     ----------------------------- */
  #chatbot-offcanvas .chat-messages .markdown-content {
    /* allow markdown HTML to wrap nicely */
    word-break: break-word;
  }
  #chatbot-offcanvas .chat-messages .markdown-content p {
    margin: 0.5rem 0;
    line-height: 1.5;
  }
  #chatbot-offcanvas .chat-messages .markdown-content p:first-child { margin-top: 0; }
  #chatbot-offcanvas .chat-messages .markdown-content p:last-child { margin-bottom: 0; }

  #chatbot-offcanvas .chat-messages .markdown-content code {
    background-color: rgba(0, 0, 0, 0.08);
    padding: 0.15em 0.35em;
    border-radius: 4px;
    font-size: 0.92em;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  #chatbot-offcanvas .chat-messages .markdown-content pre {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 0.75rem;
    border-radius: 0.5rem;
    overflow-x: auto;
    margin: 0.6rem 0;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 0.9em;
  }
  #chatbot-offcanvas .chat-messages .markdown-content pre code {
    background: transparent;
    padding: 0;
  }

  #chatbot-offcanvas .chat-messages .markdown-content ul,
  #chatbot-offcanvas .chat-messages .markdown-content ol {
    margin: 0.5rem 0;
    padding-left: 1.25rem;
  }
  #chatbot-offcanvas .chat-messages .markdown-content li {
    margin: 0.2rem 0;
    line-height: 1.5;
  }

  #chatbot-offcanvas .chat-messages .markdown-content blockquote {
    border-left: 3px solid rgba(0, 0, 0, 0.2);
    padding-left: 0.75rem;
    margin: 0.5rem 0;
    color: rgba(0, 0, 0, 0.75);
    font-style: italic;
  }

  #chatbot-offcanvas .chat-messages .markdown-content a {
    color: var(--phoenix-primary, #2A7BE4);
    text-decoration: underline;
  }
  #chatbot-offcanvas .chat-messages .markdown-content a:hover {
    text-decoration: none;
  }

  #chatbot-offcanvas .chat-messages .markdown-content hr {
    border: 0;
    border-top: 1px solid rgba(0, 0, 0, 0.12);
    margin: 0.75rem 0;
  }

  #chatbot-offcanvas .chat-messages .markdown-content table {
    border-collapse: collapse;
    width: 100%;
    margin: 0.5rem 0;
    font-size: 0.92em;
  }
  #chatbot-offcanvas .chat-messages .markdown-content th,
  #chatbot-offcanvas .chat-messages .markdown-content td {
    border: 1px solid rgba(0, 0, 0, 0.12);
    padding: 0.35rem 0.5rem;
    text-align: left;
    vertical-align: top;
  }
  #chatbot-offcanvas .chat-messages .markdown-content th {
    background: rgba(0, 0, 0, 0.04);
    font-weight: 600;
  }
  
  /* (Mermaid removed) */

  /* -----------------------------
     Rete.js-Style Flow Diagram Styles
     ----------------------------- */
  .flow-diagram-container {
    margin: 16px 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    /* Fixed visual area: diagram fits via SVG viewBox, no page scrolling */
    height: clamp(240px, 45vh, 560px);
    /* Theme-aware colors (Phoenix/Bootstrap variables) */
    --flow-bg: var(--bs-emphasis-bg, #f8f9fa);
    --flow-border: rgba(var(--bs-border-color-rgb, 222, 226, 230), 0.9);
    --flow-edge-color: rgba(var(--bs-body-color-rgb, 33, 37, 41), 0.45);
    --flow-label-color: rgba(var(--bs-body-color-rgb, 33, 37, 41), 0.85);
    --flow-label-bg: var(--bs-body-bg, #fff);
    background: var(--flow-bg);
    border: 1px solid var(--flow-border);
    position: relative;
  }

  /* (Toolbar removed as requested) */

  /* Node styles */
  .flow-node {
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .flow-node .node-shape {
    transition: all 0.2s ease;
  }

  .flow-node:hover .node-shape {
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
  }

  .flow-node.active .node-shape {
    filter: drop-shadow(0 0 12px rgba(42, 123, 228, 0.8));
    stroke: #2A7BE4 !important;
    stroke-width: 3 !important;
  }

  /* Connection styles */
  .flow-connection {
    transition: all 0.2s ease;
  }

  .flow-connection .connection-path {
    transition: all 0.2s ease;
  }

  .flow-connection:hover .connection-path {
    stroke: #2A7BE4;
    stroke-width: 3;
  }

  .flow-connection.active .connection-path {
    stroke: #2A7BE4;
    stroke-width: 3;
    stroke-dasharray: 8 6;
    animation: flowConnectionDash 1s linear infinite;
  }

  .flow-connection.active .connection-arrow {
    fill: #2A7BE4;
  }

  @keyframes flowConnectionDash {
    from { stroke-dashoffset: 0; }
    to { stroke-dashoffset: -28; }
  }

  /* Connection labels */
  .connection-label {
    pointer-events: none;
    user-select: none;
  }

  /* Node labels */
  .node-label {
    pointer-events: none;
    user-select: none;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .flow-diagram-container {
      margin: 12px 0;
    }
    
    .flow-node .node-label {
      font-size: 9px !important;
    }
    
    .connection-label {
      font-size: 8px !important;
    }
  }
</style>

<!-- Chatbot Offcanvas - Pushes main content instead of overlaying -->
<div class="offcanvas offcanvas-end chatbot-panel border-0" id="chatbot-offcanvas" tabindex="-1" aria-labelledby="chatbot-offcanvas" data-bs-backdrop="false" data-bs-scroll="true">
  <!-- Resize Handle -->
  <div class="chatbot-resize-handle" id="chatbot-resize-handle" title="Drag to resize">
    <div class="resize-handle-line"></div>
  </div>
  <div class="offcanvas-header border-bottom border-translucent px-3 py-2 d-flex align-items-center justify-content-between gap-2">
    <!-- Left: Chat tabs -->
    <ul class="nav nav-underline fs-9 flex-nowrap overflow-x-auto chatbot-tabs me-2" id="chatbot-tabs" role="tablist" aria-label="Chat tabs">
      <!-- Tabs injected by JS -->
    </ul>

    <!-- Right: Actions -->
    <div class="d-flex align-items-center gap-2 flex-shrink-0">
      <button class="btn btn-link p-0 d-flex align-items-center" type="button" id="chatbot-new-tab" aria-label="New chat tab" title="New chat">
        <span class="fas fa-plus text-body"></span>
      </button>

      <div class="dropdown">
        <button class="btn btn-link p-0 dropdown-toggle dropdown-caret-none transition-none d-flex align-items-center" type="button" id="chatbot-history-dropdown" data-bs-toggle="dropdown" data-boundary="window" aria-haspopup="true" aria-expanded="false" aria-label="Chat history" title="Chat history">
          <span class="far fa-clock text-body"></span>
        </button>
        <div class="dropdown-menu dropdown-menu-end py-2" aria-labelledby="chatbot-history-dropdown">
          <h6 class="dropdown-header">Chat history (dummy)</h6>
          <a class="dropdown-item" href="#!">New chat 1 â€” Camera status</a>
          <a class="dropdown-item" href="#!">New chat 2 â€” Events today</a>
          <a class="dropdown-item" href="#!">New chat 3 â€” Agent settings</a>
          <div class="dropdown-divider"></div>
          <a class="dropdown-item text-body-tertiary" href="#!">Later weâ€™ll connect realtime history</a>
        </div>
      </div>

      <div class="btn-reveal-trigger">
        <button class="btn btn-link p-0 dropdown-toggle dropdown-caret-none transition-none d-flex align-items-center" type="button" id="chatbot-dropdown" data-bs-toggle="dropdown" data-boundary="window" aria-haspopup="true" aria-expanded="false" data-bs-reference="parent" aria-label="More options" title="More options">
          <span class="fas fa-ellipsis-h text-body"></span>
        </button>
        <div class="dropdown-menu dropdown-menu-end py-2" aria-labelledby="chatbot-dropdown">
          <a class="dropdown-item" href="#!" data-chatbot-action="clear">Clear chat</a>
          <a class="dropdown-item" href="#!">Search in chat</a>
          <a class="dropdown-item" href="#!">Show history</a>
          <a class="dropdown-item" href="#!">Settings</a>
        </div>
      </div>

      <button class="btn p-1 fw-bolder" type="button" data-bs-dismiss="offcanvas" aria-label="Close">
        <span class="fas fa-times fs-8"></span>
      </button>
    </div>
  </div>
  <div class="offcanvas-body p-0 d-flex flex-column">
    <div class="card-body chat p-0 flex-1 d-flex flex-column">
      <div class="chat-messages d-flex flex-column scrollbar h-100 p-3">
        <!-- Intentionally blank: we don't show any welcome/suggestion content -->
      </div>
    </div>
    <div class="card-footer border-top border-translucent px-3 py-3">
      <div class="border border-translucent px-2 py-2 chatbot-composer">
        <!-- Controls row (visually bottom; stays pinned when textarea grows) -->
        <div class="d-flex align-items-center justify-content-between gap-2">
          <div class="dropdown">
            <button class="btn btn-link p-0 dropdown-toggle dropdown-caret-none transition-none d-flex align-items-center text-body-tertiary fs-9" type="button" id="chatbot-mode-dropdown" data-bs-toggle="dropdown" aria-expanded="false">
              <span id="chatbot-mode-label">General</span>
            </button>
            <ul class="dropdown-menu" aria-labelledby="chatbot-mode-dropdown">
              <li><a class="dropdown-item" href="#!" data-chatbot-mode="general">General</a></li>
              <li><a class="dropdown-item" href="#!" data-chatbot-mode="agent">Agent</a></li>
            </ul>
          </div>

          <div class="d-flex align-items-center gap-3">
            <button class="btn btn-link p-0 text-body-tertiary d-flex align-items-center" type="button" id="chatbot-voice-btn" aria-label="Voice assistant" title="Voice assistant">
              <span class="fa-solid fa-microphone fs-8"></span>
            </button>
            <button class="btn btn-link p-0 text-body-tertiary d-flex align-items-center send-btn" type="button" aria-label="Send" title="Send">
              <span class="fa-solid fa-paper-plane fs-8"></span>
            </button>
          </div>
        </div>

        <!-- Textarea (visually top; grows upward only because of column-reverse) -->
        <textarea class="form-control border-0 shadow-none w-100 fs-9" placeholder="Write message" id="chatbot-input" rows="1"></textarea>
      </div>
    </div>
  </div>
</div>

<!-- Toggle Button for Chatbot -->
<a class="card setting-toggle" href="#chatbot-offcanvas" data-bs-toggle="offcanvas" aria-controls="chatbot-offcanvas">
  <div class="card-body d-flex align-items-center px-3 py-2">
    <div class="position-relative rounded-start chatbot-toggle-icon">
      <div class="settings-popover"><span class="ripple"><span class="fa-spin position-absolute all-0 d-flex flex-center"><span class="icon-spin position-absolute all-0 d-flex flex-center">
        <svg width="20" height="20" viewBox="0 0 20 20" fill="#ffffff" xmlns="http://www.w3.org/2000/svg">
          <path d="M10 2C5.58 2 2 5.58 2 10c0 1.54.36 2.98 1 4.28L1 19l4.72-1c1.3.64 2.74 1 4.28 1 4.42 0 8-3.58 8-8s-3.58-8-8-8zm0 14.5c-1.19 0-2.38-.31-3.34-.84l-.24-.12-2.5.65.65-2.5-.12-.24C4.31 12.38 4 11.19 4 10c0-3.31 2.69-6 6-6s6 2.69 6 6-2.69 6-6 6z" fill="#2A7BE4"></path>
        </svg></span></span></span></div>
    </div><small class="text-uppercase text-body-tertiary fw-bold py-2 pe-2 ps-1 rounded-end">chat</small>
  </div>
</a>

<!-- Custom JavaScript for Chatbot Push Behavior -->
<script>
  (function() {
    'use strict';

    // -----------------------------
    // Markdown deps loader (local vendor files)
    // -----------------------------
    function vendorPath(relFromVendors) {
      // Robust across:
      // - http(s)://.../pages/*.html  â†’ ../vendors/...
      // - file:///C:/.../pages/*.html â†’ ../vendors/...
      // - http(s)://.../*.html (root) â†’ vendors/...
      // This avoids broken "../" repeats on Windows file:// paths.
      const path = String(window.location.pathname || '').replace(/\\/g, '/');
      const vendorsRel = path.includes('/pages/') ? '../vendors/' : 'vendors/';
      return new URL(vendorsRel + relFromVendors, window.location.href).toString();
    }

    function loadScriptOnce(src) {
      return new Promise((resolve, reject) => {
        try {
          const existing = document.querySelector(`script[src="${src}"]`);
          if (existing) return resolve();
          const scriptEl = document.createElement('script');
          scriptEl.src = src;
          scriptEl.defer = true;
          scriptEl.onload = () => resolve();
          scriptEl.onerror = () => reject(new Error(`Failed to load script: ${src}`));
          document.head.appendChild(scriptEl);
        } catch (e) {
          reject(e);
        }
      });
    }

    // Best-effort: loads deps in background; renderer will fall back to plain text until available.
    function ensureMarkdownDeps() {
      if (window.marked && window.DOMPurify) return Promise.resolve();
      const markedSrc = vendorPath('marked/marked.min.js');
      const purifySrc = vendorPath('dompurify/purify.min.js');
      return loadScriptOnce(markedSrc)
        .then(() => loadScriptOnce(purifySrc))
        .catch((e) => {
          console.warn('Markdown deps load failed:', e);
        });
    }

    // Load Rete.js-style flow renderer (custom, no external deps)
    function ensureReteFlowRenderer() {
      if (window.reteFlowRenderer && window.flowTransforms) return Promise.resolve();
      
      // Load transformation utilities first
      const transformsSrc = (() => {
        const path = String(window.location.pathname || '').replace(/\\/g, '/');
        const customJsRel = path.includes('/pages/') ? '../custom_js/' : 'custom_js/';
        return new URL(customJsRel + 'flow-transforms.js', window.location.href).toString();
      })();
      
      // Load renderer
      const rendererSrc = (() => {
        const path = String(window.location.pathname || '').replace(/\\/g, '/');
        const customJsRel = path.includes('/pages/') ? '../custom_js/' : 'custom_js/';
        return new URL(customJsRel + 'rete-flow-renderer.js', window.location.href).toString();
      })();
      
      return loadScriptOnce(transformsSrc)
        .then(() => loadScriptOnce(rendererSrc))
        .then(() => {
          console.log('[rete-flow] Rete flow renderer initialized');
        })
        .catch((e) => {
          console.warn('Rete flow renderer load failed:', e);
        });
    }

    // (Mermaid removed)
    
    // Global flag to block heavy layout work during transitions
    let layoutSettling = false;
    
    function initChatbotPush() {
      const chatbotOffcanvas = document.getElementById('chatbot-offcanvas');
      const viewportElement = document.querySelector('.viewport-scrolls');
      const contentElement = document.querySelector('.content');
      const bodyElement = document.body;
      
      if (!chatbotOffcanvas) return;

      // Hoist the top navbar into its own grid row (so it doesn't shrink/scroll with content)
      // This avoids rewriting the large navbar HTML; we just move the existing DOM node once.
      (function hoistTopNavbar() {
        const existing = document.querySelector('.viewport-scrolls > .navbar-top');
        const main = document.querySelector('main.main');
        if (!existing || !main) return;
        if (existing.dataset.hoisted === 'true') return;
        existing.dataset.hoisted = 'true';
        // Move navbar to be the first element before main content shell
        document.body.insertBefore(existing, main);
      })();
      
      const DEFAULT_CHATBOT_WIDTH = 400;
      const MIN_CHATBOT_WIDTH = 300;
      const MAX_CHATBOT_WIDTH = 1200;

      // Prevent flip-flopping around the default width while dragging.
      // Expand/collapse thresholds create hysteresis (stable UX).
      const EXPAND_AT = 420;
      const COLLAPSE_AT = 380;
      let expandedState = false;
      
      // Get saved width or use default
      function getChatbotWidth() {
        const saved = localStorage.getItem('chatbotWidth');
        return saved ? parseInt(saved, 10) : DEFAULT_CHATBOT_WIDTH;
      }
      
      // Save width to localStorage
      function saveChatbotWidth(width) {
        localStorage.setItem('chatbotWidth', width.toString());
      }
      
      // Update chatbot width and grid column
      function setChatbotWidth(width) {
        width = Math.max(MIN_CHATBOT_WIDTH, Math.min(MAX_CHATBOT_WIDTH, width));
        chatbotOffcanvas.style.width = width + 'px';
        bodyElement.style.setProperty('--chatbot-width', width + 'px');
        // Amount beyond the default 400px. Used to keep content width stable in expanded mode.
        const excess = Math.max(0, width - DEFAULT_CHATBOT_WIDTH);
        bodyElement.style.setProperty('--chatbot-excess', excess + 'px');
        saveChatbotWidth(width);
        updateLayoutBehavior(width);
      }
      
      // Update layout behavior based on chatbot width
      function updateLayoutBehavior(chatbotWidth) {
        if (!contentElement) return;

        // Update stable expanded state with hysteresis thresholds
        if (!expandedState && chatbotWidth >= EXPAND_AT) {
          expandedState = true;
        } else if (expandedState && chatbotWidth <= COLLAPSE_AT) {
          expandedState = false;
        }

        if (expandedState) {
          // EXPANDED: viewport gets horizontal scroll; content width stays as-if chatbot=400px
          bodyElement.classList.add('chatbot-open', 'chatbot-expanded');
          if (viewportElement) {
            viewportElement.classList.add('chatbot-expanded');
          }
          contentElement.classList.add('chatbot-expanded');
        } else {
          // DEFAULT (â‰¤400px): Grid handles sizing, NO margin needed
          bodyElement.classList.add('chatbot-open');
          bodyElement.classList.remove('chatbot-expanded');
          if (viewportElement) {
            viewportElement.classList.remove('chatbot-expanded');
          }
          // Clear any inline styles (grid handles sizing automatically)
          contentElement.style.minWidth = '';
          contentElement.classList.remove('chatbot-expanded');
        }
      }
      
      function updateLayoutState(isOpen) {
        if (isOpen) {
          const currentWidth = getChatbotWidth();
          // Initialize stable expanded state based on stored width
          expandedState = currentWidth > DEFAULT_CHATBOT_WIDTH;
          setChatbotWidth(currentWidth); // This will also update layout
        } else {
          expandedState = false;
          bodyElement.classList.remove('chatbot-open', 'chatbot-expanded');
          bodyElement.style.setProperty('--chatbot-width', '0px');
          bodyElement.style.setProperty('--chatbot-excess', '0px');
          if (viewportElement) {
            viewportElement.classList.remove('chatbot-expanded');
          }
          if (contentElement) {
            contentElement.classList.remove('chatbot-expanded');
            contentElement.style.minWidth = '';
          }
        }
      }
      
      // Initialize resize functionality
      function initChatbotResize() {
        const resizeHandle = document.getElementById('chatbot-resize-handle');
        if (!resizeHandle || !chatbotOffcanvas) return;
        
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;
        
        function getIsRTL() {
          return document.documentElement.getAttribute('dir') === 'rtl';
        }
        
        resizeHandle.addEventListener('mousedown', function(e) {
          if (!chatbotOffcanvas.classList.contains('show')) return;
          
          isResizing = true;
          startX = e.clientX;
          startWidth = parseInt(window.getComputedStyle(chatbotOffcanvas).width, 10);
          
          document.body.classList.add('chatbot-resizing');
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';
          
          e.preventDefault();
          e.stopPropagation();
        });
        
        document.addEventListener('mousemove', function(e) {
          if (!isResizing) return;
          
          const isRTL = getIsRTL();
          // For right-side offcanvas (offcanvas-end):
          // - Dragging LEFT (negative deltaX) should INCREASE width (handle moves left, chatbot expands)
          // - Dragging RIGHT (positive deltaX) should DECREASE width (handle moves right, chatbot shrinks)
          // So we need to INVERT the deltaX
          let deltaX = isRTL ? (e.clientX - startX) : (startX - e.clientX);
          const newWidth = startWidth + deltaX;
          
          setChatbotWidth(newWidth);
          
          e.preventDefault();
        });
        
        document.addEventListener('mouseup', function() {
          if (isResizing) {
            isResizing = false;
            document.body.classList.remove('chatbot-resizing');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            // ðŸ”’ Block chart resize temporarily during CSS transition
            // ECharts will permanently break if resize() is called with invalid dimensions (0Ã—0 or 1-5px)
            layoutSettling = true;
            
            // Wait for CSS grid + transitions to fully settle (3 RAF frames = ~50ms at 60fps)
            // This ensures container has stable, valid dimensions before any ResizeObserver fires
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  layoutSettling = false;
                  
                  // ðŸ”¥ NOW it is safe to resize charts - dispatch custom event for chart instances
                  document.dispatchEvent(new Event('chatbot:layout-settled'));
                });
              });
            });
          }
        });
        
        // Prevent text selection while resizing
        resizeHandle.addEventListener('selectstart', function(e) {
          e.preventDefault();
          return false;
        });
        
        resizeHandle.addEventListener('dragstart', function(e) {
          e.preventDefault();
          return false;
        });
      }
      
      // Initialize width immediately (before any show events)
      // This ensures the correct width is set even on first open
      const initialWidth = getChatbotWidth();
      chatbotOffcanvas.style.width = initialWidth + 'px';
      bodyElement.style.setProperty('--chatbot-width', initialWidth + 'px');
      const excess = Math.max(0, initialWidth - DEFAULT_CHATBOT_WIDTH);
      bodyElement.style.setProperty('--chatbot-excess', excess + 'px');
      
      // Handle chatbot show/hide with grid layout
      chatbotOffcanvas.addEventListener('show.bs.offcanvas', function(e) {
        // Set width BEFORE animation starts so it opens with correct width
        const savedWidth = getChatbotWidth();
        setChatbotWidth(savedWidth);
        updateLayoutState(true);
        localStorage.setItem('chatbotOpen', 'true');
      });
      
      chatbotOffcanvas.addEventListener('shown.bs.offcanvas', function() {
        // Ensure width is still correct after animation
        const savedWidth = getChatbotWidth();
        setChatbotWidth(savedWidth);
        localStorage.setItem('chatbotOpen', 'true');
      });
      
      // Handle offcanvas hide event
      chatbotOffcanvas.addEventListener('hide.bs.offcanvas', function() {
        updateLayoutState(false);
        localStorage.setItem('chatbotOpen', 'false');
      });
      
      // Handle offcanvas hidden event (after animation completes)
      chatbotOffcanvas.addEventListener('hidden.bs.offcanvas', function() {
        updateLayoutState(false);
        localStorage.setItem('chatbotOpen', 'false');
      });
      
      // Also handle when offcanvas is already shown on page load
      if (chatbotOffcanvas.classList.contains('show')) {
        const savedWidth = getChatbotWidth();
        chatbotOffcanvas.style.width = savedWidth + 'px';
        updateLayoutBehavior(savedWidth);
        updateLayoutState(true);
      }
      
      // Initialize resize functionality
      initChatbotResize();
    }

    function initChatbotComposer() {
      const textarea = document.getElementById('chatbot-input');
      const sendBtn = document.querySelector('#chatbot-offcanvas .send-btn');
      if (!textarea) return;

      function autosize() {
        // Reset then grow to fit content (up to max-height via CSS)
        textarea.style.height = 'auto';
        const cs = window.getComputedStyle(textarea);
        const lh = parseFloat(cs.lineHeight);
        const lineHeight = Number.isFinite(lh) ? lh : 16;
        const pt = parseFloat(cs.paddingTop) || 0;
        const pb = parseFloat(cs.paddingBottom) || 0;
        const max = (lineHeight * 4) + pt + pb; // 4 lines max
        const next = Math.min(textarea.scrollHeight, max);
        textarea.style.height = next + 'px';
      }

      textarea.addEventListener('input', autosize);
      autosize();

      // Enter = send, Shift+Enter = newline
      textarea.addEventListener('keydown', function(e) {
        if (e.key !== 'Enter') return;
        if (e.shiftKey) return; // allow newline

        e.preventDefault();
        if (sendBtn) sendBtn.click();
      });
    }

    function initChatbotTabs() {
      const chatbotOffcanvas = document.getElementById('chatbot-offcanvas');
      const tabsEl = document.getElementById('chatbot-tabs');
      const newTabBtn = document.getElementById('chatbot-new-tab');
      const messagesEl = chatbotOffcanvas?.querySelector?.('.chat-messages');
      const textarea = document.getElementById('chatbot-input');
      const sendBtn = chatbotOffcanvas?.querySelector?.('.send-btn');
      const modeLabel = document.getElementById('chatbot-mode-label');
      const voiceBtn = document.getElementById('chatbot-voice-btn');

      if (!chatbotOffcanvas || !tabsEl || !messagesEl) return;

      // Kick off markdown deps load early (non-blocking)
      ensureMarkdownDeps();
      // Rete flow renderer loaded on-demand when diagrams are present
      ensureReteFlowRenderer();

      // Treat current markup as the "blank chat" template for new tabs
      const initialTemplate = messagesEl.innerHTML;

      const MODES = /** @type {const} */ (['general', 'agent']);

      let tabCounter = 0;
      /** @type {{sessionId: string|null, html: string, started: boolean} } */
      const emptyModeState = () => ({ sessionId: null, html: initialTemplate, started: false });

      /** @type {{id: string, title: string, mode: Record<string, {sessionId: string|null, html: string}>}[]} */
      const tabs = [];
      let activeId = null;

      function escapeHtml(s) {
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;');
      }

      function getActive() {
        return tabs.find(t => t.id === activeId) || null;
      }

      function getMode() {
        const m = chatbotOffcanvas.dataset.chatbotMode;
        return m === 'agent' ? 'agent' : 'general';
      }

      function setMode(nextMode) {
        const mode = nextMode === 'agent' ? 'agent' : 'general';
        const prev = getMode();
        const active = getActive();
        if (!active) {
          chatbotOffcanvas.dataset.chatbotMode = mode;
          if (modeLabel) modeLabel.textContent = mode === 'agent' ? 'Agent' : 'General';
          return;
        }

        // Save current mode view before switching
        active.mode[prev].html = messagesEl.innerHTML;

        chatbotOffcanvas.dataset.chatbotMode = mode;
        if (modeLabel) modeLabel.textContent = mode === 'agent' ? 'Agent' : 'General';

        // Load new mode view for this tab
        messagesEl.innerHTML = active.mode[mode].html || initialTemplate;
      }

      function saveActiveHtml() {
        const active = getActive();
        if (!active) return;
        const mode = getMode();
        active.mode[mode].html = messagesEl.innerHTML;
      }

      function renderTabs() {
        tabsEl.innerHTML = tabs
          .map(t => {
            const isActive = t.id === activeId;
            return `
              <li class="nav-item" role="presentation" data-chatbot-tab="${t.id}">
                <button class="nav-link ${isActive ? 'active' : ''} pe-2"
                        type="button"
                        role="tab"
                        aria-selected="${isActive ? 'true' : 'false'}"
                        data-chatbot-tab-btn="${t.id}">
                  <span class="text-truncate d-inline-block chatbot-tab-name">${escapeHtml(t.title)}</span>
                  <span class="chatbot-tab-close ms-2 text-body-tertiary"
                        role="button"
                        tabindex="0"
                        aria-label="Close tab"
                        data-chatbot-tab-close="${t.id}">
                    <span class="fas fa-times"></span>
                  </span>
                </button>
              </li>
            `;
          })
          .join('');
      }

      function showTab(id) {
        const target = tabs.find(t => t.id === id);
        if (!target) return;
        saveActiveHtml();
        activeId = id;
        const mode = getMode();
        messagesEl.innerHTML = target.mode[mode].html || initialTemplate;
        renderTabs();
      }

      function createTab(title) {
        saveActiveHtml();
        tabCounter += 1;
        const id = `chat_tab_${Date.now()}_${tabCounter}`;
        tabs.push({
          id,
          title: title || `New chat ${tabCounter}`,
          mode: {
            general: emptyModeState(),
            agent: emptyModeState()
          }
        });
        activeId = id;
        renderTabs();
        messagesEl.innerHTML = initialTemplate;
      }

      function closeTab(id) {
        if (tabs.length <= 1) {
          // Always keep at least one tab
          const only = tabs[0];
          only.title = 'New chat 1';
          only.mode.general = emptyModeState();
          only.mode.agent = emptyModeState();
          activeId = only.id;
          messagesEl.innerHTML = initialTemplate;
          renderTabs();
          return;
        }

        const idx = tabs.findIndex(t => t.id === id);
        if (idx === -1) return;

        const wasActive = activeId === id;
        tabs.splice(idx, 1);

        if (!wasActive) {
          renderTabs();
          return;
        }

        const next = tabs[Math.max(0, idx - 1)];
        activeId = next.id;
        const mode = getMode();
        messagesEl.innerHTML = next.mode[mode].html || initialTemplate;
        renderTabs();
      }

      function appendUserBubble(text) {
        const trimmed = (text || '').trim();
        if (!trimmed) return false;
        messagesEl.insertAdjacentHTML(
          'beforeend',
          `
            <div class="d-flex justify-content-end mt-2">
              <div class="bg-primary text-white rounded-2 px-3 py-2 fs-9 text-break">
                ${escapeHtml(trimmed)}
              </div>
            </div>
          `
        );
        return true;
      }

      async function renderFlowDiagram(pendingId, flowDiagramData) {
        try {
          // Validate flow data
          if (!window.flowTransforms || !window.flowTransforms.isValid(flowDiagramData)) {
            console.warn('[chatbot] Invalid flow diagram data');
            return;
          }

          // Find the pending message wrapper using the correct attribute
          const pendingNode = messagesEl.querySelector(`[data-chatbot-pending="${pendingId}"]`);
          if (!pendingNode) {
            console.warn('[chatbot] Pending node not found for pendingId:', pendingId);
            return;
          }

          // Always append INSIDE the assistant bubble (not as a sibling in the flex row)
          const bubble = pendingNode.querySelector?.('div');
          if (!bubble) {
            console.warn('[chatbot] Bubble not found in pending node:', pendingId);
            return;
          }

          // Create a unique container ID for this diagram
          const diagramId = `flow-diagram-${pendingId}`;
          
          // Check if container already exists (avoid duplicates)
          if (document.getElementById(diagramId)) {
            console.warn('[chatbot] Flow diagram already rendered for:', pendingId);
            return;
          }

          // Create diagram container and insert UNDER the bubble content
          const container = document.createElement('div');
          container.id = diagramId;
          container.className = 'flow-diagram-container mt-3';
          container.style.width = '100%';
          bubble.appendChild(container);

          // Ensure Rete renderer is loaded
          await ensureReteFlowRenderer();
          
          if (!window.reteFlowRenderer) {
            throw new Error('Rete flow renderer not available');
          }

          // Transform generic data to Rete format
          const reteData = window.flowTransforms.toRete(flowDiagramData);

          // Render the diagram
          await window.reteFlowRenderer.render(diagramId, reteData, {
            readonly: true,
            autoLayout: true,
            layoutDirection: 'horizontal-wrap',
            // spacing.x/y are treated as GAPs between nodes (not absolute step)
            nodeSpacing: { x: 28, y: 54 },
            wrapColumns: 3,
            enablePanZoom: true,
            fitOnInit: true,
            minScale: 0.5,
            maxScale: 2.2,
            animate: true
          });

          console.log('[chatbot] Flow diagram rendered successfully:', diagramId);
        } catch (error) {
          console.error('[chatbot] Failed to render flow diagram:', error);
          // Don't show error to user, just log it
        }
      }

      function appendAssistantPending() {
        const id = `pending_${Date.now()}_${Math.random().toString(16).slice(2)}`;
        messagesEl.insertAdjacentHTML(
          'beforeend',
          `
            <div class="d-flex justify-content-start mt-2" data-chatbot-pending="${id}">
              <div class="bg-body-secondary rounded-2 px-3 py-2 fs-9 text-body-emphasis text-break markdown-content">
                ...
              </div>
            </div>
          `
        );
        return id;
      }

      // ECharts rendering removed. Mermaid will render diagrams on DONE only.

      function replaceAssistantPending(pendingId, text, isError = false) {
        const node = messagesEl.querySelector?.(`[data-chatbot-pending="${pendingId}"]`);
        if (!node) return;
        const bubble = node.querySelector?.('div');
        if (!bubble) return;
        const msg = text || '';

        if (isError) {
          bubble.textContent = msg;
          bubble.classList.remove('bg-body-secondary');
          bubble.classList.add('bg-danger', 'text-white');
          return;
        }

        // Ensure styling hook exists for markdown CSS
        bubble.classList.add('markdown-content');

        // ChatGPT-style flow blocks: extract completed ```flow ... ``` blocks on DONE only.
        // Replace each extracted block with a stable placeholder <div> at the same position.
        function extractMermaidBlocks(markdownText) {
          // Mermaid support removed; keep text unchanged.
          const src = String(markdownText || '');
          return { markdown: src, diagrams: [] };
          // (legacy Mermaid extraction code removed)
          const diagrams = [];

          const safePendingId = String(pendingId || '').replace(/[^a-zA-Z0-9_-]/g, '_');
          let out = '';
          let i = 0;
          let n = 0;

          while (true) {
            const start = src.indexOf('```mermaid', i);
            if (start === -1) break;

            out += src.slice(i, start);

            const lineEnd = src.indexOf('\n', start);
            if (lineEnd === -1) {
              // Incomplete fence line; keep as-is
              out += src.slice(start);
              i = src.length;
              break;
            }

            // Find a closing fence that starts a line.
            let close = src.indexOf('\n```', lineEnd + 1);
            while (close !== -1) {
              const after = close + 4; // "\n```" length
              if (after >= src.length) break;
              const ch = src[after];
              if (ch === '\n') break;
              if (ch === '\r' && src[after + 1] === '\n') break;
              // Not a real closing fence; keep searching
              close = src.indexOf('\n```', close + 1);
            }

            if (close === -1) {
              // Incomplete flow block; keep as-is (we only extract completed blocks on done)
              out += src.slice(start);
              i = src.length;
              break;
            }

            const payloadText = src.slice(lineEnd + 1, close).trim();

            // Advance i past the closing fence line
            let nextIdx = close + 4;
            if (src[nextIdx] === '\r' && src[nextIdx + 1] === '\n') nextIdx += 2;
            else if (src[nextIdx] === '\n') nextIdx += 1;

            const containerId = `mermaid-${safePendingId}-${n++}`;
            diagrams.push({ containerId, mermaidText: payloadText });

            // Insert Mermaid container (frontend-only HTML injection, backend stays text-only).
            // Mermaid will replace this div contents after DONE.
            const safeText = escapeHtml(payloadText);
            const safeB64 = (() => {
              try { return btoa(unescape(encodeURIComponent(payloadText))); } catch (_) { return ''; }
            })();
            out +=
              '\n\n' +
              `<div id="${containerId}" class="mermaid flow-diagram-placeholder" data-mermaid-src-b64="${safeB64}" ` +
              `style="width: 100%; min-height: 360px; margin-top: 1rem; margin-bottom: 1rem; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 0.5rem; padding: 0.5rem;">` +
              `${safeText}` +
              `</div>` +
              '\n\n';

            i = nextIdx;
          }

          out += src.slice(i);
          return { markdown: out, diagrams };
        }

        const extracted = extractMermaidBlocks(msg);
        const msgWithoutFlow = extracted.markdown;
        const mermaidDiagrams = [];

        // n8n-style preview animation (UI-only)
        function startMermaidPreviewAnimationForBubble(bubbleEl) {
          try {
            const debugMermaid = (() => {
              try { return localStorage.getItem('chatbot_mermaid_debug') === 'true'; } catch (_) { return false; }
            })();
            const dbg = (...args) => { if (debugMermaid) console.log('[mermaid-preview]', ...args); };

            const mermaidDivs = Array.from(bubbleEl.querySelectorAll?.('.mermaid') || []);
            if (!mermaidDivs.length) {
              dbg('no .mermaid divs in bubble');
              return;
            }

            // If Mermaid hasn't inserted SVG yet, retry shortly (don't mark started).
            const hasAnySvg = mermaidDivs.some(d => d.querySelector('svg'));
            if (!hasAnySvg) {
              dbg('svg not present yet; scheduling retry');
              if (!bubbleEl._mermaidPreviewRetryTimer) {
                bubbleEl._mermaidPreviewRetryTimer = setTimeout(() => {
                  bubbleEl._mermaidPreviewRetryTimer = null;
                  startMermaidPreviewAnimationForBubble(bubbleEl);
                }, 120);
              }
              return;
            }

            // Start once per rendered message bubble (after SVG exists)
            if (bubbleEl._mermaidPreviewStarted) {
              dbg('already started; skipping');
              return;
            }
            bubbleEl._mermaidPreviewStarted = true;

            bubbleEl.classList.add('mermaid-preview-running');
            // Also tag the diagram containers for selector robustness
            mermaidDivs.forEach(d => d.classList.add('mermaid-preview-running'));
            dbg('started; mermaidDivs=', mermaidDivs.length);

            // Parse an ordered list of node IDs from mermaid source (first diagram only).
            // This is a preview loop; it does not represent real execution.
            function decodeMermaidSrc(div) {
              const b64 = div?.dataset?.mermaidSrcB64 || '';
              if (!b64) return (div?.textContent || '');
              try { return decodeURIComponent(escape(atob(b64))); } catch (_) { return (div?.textContent || ''); }
            }

            function parseMermaidGraph(src) {
              const srcNorm = String(src || '').replace(/\r\n/g, '\n');
              const lines = srcNorm.split('\n').map(l => l.trim()).filter(Boolean);
              const nodeOrder = [];
              const seen = new Set();
              const edges = []; // {src, dst}

              // Use RegExp(...) to avoid HTML/JS parser edge cases in some editors
              const edgeRe = new RegExp('^([A-Za-z0-9_]+)\\\\s*(?:--\\\\s*\".*?\"\\\\s*)?-->\\\\s*([A-Za-z0-9_]+)');
              const edgeRe2 = new RegExp('^([A-Za-z0-9_]+)\\\\s*-->\\\\s*([A-Za-z0-9_]+)');
              const nodeRe = new RegExp('^([A-Za-z0-9_]+)\\\\s*(?:\\\\[\\\\s*\".*?\"\\\\s*\\\\]|\\\\{\\\\s*\".*?\"\\\\s*\\\\})');

              for (const line of lines) {
                let m = line.match(edgeRe) || line.match(edgeRe2);
                if (m) {
                  const a = m[1], b = m[2];
                  edges.push({ src: a, dst: b });
                  if (!seen.has(a)) { seen.add(a); nodeOrder.push(a); }
                  if (!seen.has(b)) { seen.add(b); nodeOrder.push(b); }
                  continue;
                }
                m = line.match(nodeRe);
                if (m) {
                  const a = m[1];
                  if (!seen.has(a)) { seen.add(a); nodeOrder.push(a); }
                }
              }

              // Fallback to any ids found
              return { nodeOrder, edges };
            }

            // Build one combined preview loop per bubble (across all diagrams)
            const diagrams = mermaidDivs
              .map(div => {
                const src = decodeMermaidSrc(div);
                const parsed = parseMermaidGraph(src);
                return { div, ...parsed };
              })
              .filter(d => d.nodeOrder.length);

            if (!diagrams.length) {
              dbg('no diagrams with nodeOrder found (parse failed?)');
              return;
            }
            dbg('parsed diagrams=', diagrams.length, 'first nodeOrder len=', diagrams[0]?.nodeOrder?.length, 'edges=', diagrams[0]?.edges?.length);

            function findNodeEl(svg, nodeId) {
              if (!svg || !nodeId) return null;
              const esc = (window.CSS && CSS.escape) ? CSS.escape(nodeId) : nodeId.replace(/[^\w-]/g, '_');
              // Mermaid ids vary by version; match substring.
              return svg.querySelector(`g.node[id*="${esc}"]`) || svg.querySelector(`g.node [id*="${esc}"]`)?.closest?.('g.node') || null;
            }

            function findOutgoingEdgeGroups(svg, nodeId, edges) {
              const esc = (window.CSS && CSS.escape) ? CSS.escape(nodeId) : nodeId.replace(/[^\w-]/g, '_');
              const outgoing = edges.filter(e => e.src === nodeId);
              if (!outgoing.length) return [];
              const groups = [];
              for (const e of outgoing) {
                const dstEsc = (window.CSS && CSS.escape) ? CSS.escape(e.dst) : String(e.dst).replace(/[^\w-]/g, '_');
                // edgePath ids usually include both src and dst; match both.
                const g = svg.querySelector(`g.edgePath[id*="${esc}"][id*="${dstEsc}"]`);
                if (g) groups.push(g);
              }
              return groups;
            }

            // Main loop: highlight next node every 650ms
            const intervalMs = 650;
            let idx = 0;

            function clearActive() {
              for (const d of diagrams) {
                const svg = d.div.querySelector('svg');
                if (!svg) continue;
                svg.querySelectorAll('g.node.preview-node-active').forEach(el => el.classList.remove('preview-node-active'));
                svg.querySelectorAll('g.edgePath.preview-edge-active').forEach(el => el.classList.remove('preview-edge-active'));
              }
            }

            function step() {
              clearActive();
              for (const d of diagrams) {
                const svg = d.div.querySelector('svg');
                if (!svg) continue;
                const nodeId = d.nodeOrder[idx % d.nodeOrder.length];
                const nodeEl = findNodeEl(svg, nodeId);
                if (nodeEl) nodeEl.classList.add('preview-node-active');
                const outEdges = findOutgoingEdgeGroups(svg, nodeId, d.edges);
                outEdges.forEach(g => g.classList.add('preview-edge-active'));
              }
              idx += 1;
            }

            // Start only after at least one svg exists
            const hasSvg = diagrams.some(d => d.div.querySelector('svg'));
            if (!hasSvg) return;

            step();
            bubbleEl._mermaidPreviewTimer = setInterval(step, intervalMs);
            dbg('interval started every', intervalMs, 'ms');
          } catch (_) {
            // ignore preview failures
          }
        }

        // Render markdown if deps available; else fall back to plain text
        try {
          if (window.marked && window.DOMPurify) {
            // Allow div (placeholders). Do NOT allow script.
            const allowedTags = [
              'p', 'br', 'strong', 'em', 'u', 's',
              'code', 'pre',
              'ul', 'ol', 'li',
              'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
              'blockquote', 'a', 'hr',
              'table', 'thead', 'tbody', 'tr', 'th', 'td',
              'div'
            ];
            
            // Parse markdown (marked.js preserves HTML tags by default)
            let rawHtml;
            try {
              if (window.marked && typeof window.marked.parse === 'function') {
                // Try with options if supported (newer versions)
                if (window.marked.setOptions) {
                  rawHtml = window.marked.parse(msgWithoutFlow);
                } else {
                  rawHtml = window.marked.parse(msgWithoutFlow);
                }
              } else {
                rawHtml = msgWithoutFlow; // Fallback to raw text
              }
            } catch (e) {
              console.warn('Markdown parsing failed:', e);
              rawHtml = msgWithoutFlow;
            }
            const cleanHtml = window.DOMPurify.sanitize(rawHtml, {
              ALLOWED_TAGS: allowedTags,
              ALLOWED_ATTR: ['href', 'title', 'target', 'rel', 'id', 'style', 'type', 'class'],
              KEEP_CONTENT: true,  // Preserve content
              ADD_ATTR: ['id', 'style', 'class']  // Ensure these attributes are kept
            });
            
            // Set the HTML atomically (placeholders already included)
            bubble.innerHTML = cleanHtml;
            
            // Best-effort: ensure safe link behavior
            bubble.querySelectorAll?.('a[href]')?.forEach(a => {
              a.setAttribute('target', '_blank');
              a.setAttribute('rel', 'noopener noreferrer');
            });

            // Mermaid rendering removed.
          } else {
            bubble.textContent = msg;
          }
        } catch (e) {
          console.warn('Markdown render failed:', e);
          bubble.textContent = msg;
        }
      }

      // -----------------------------
      // Streaming Markdown Rendering (ChatGPT-style)
      // -----------------------------
      function safeMarkdownForStreaming(text) {
        let t = String(text || '');

        // Diagrams: treat ```flow blocks as unstable during streaming.
        // Do NOT render diagrams; replace with a stable placeholder and never initialize ECharts here.
        (function suppressMermaidBlocks() {
          const placeholder =
            '\n\n' +
            '<div class="flow-diagram-placeholder" ' +
            'style="width:100%;height:360px;margin-top:1rem;margin-bottom:1rem;' +
            'background:#f8f9fa;border:1px solid #dee2e6;border-radius:0.5rem;' +
            'display:flex;align-items:center;justify-content:center;color:#6c757d;font-size:0.95rem;">' +
            'Rendering diagramâ€¦' +
            '</div>\n\n';

          let src = t;
          let out = '';
          let i = 0;
          while (true) {
            const start = src.indexOf('```mermaid', i);
            if (start === -1) break;

            out += src.slice(i, start);

            const lineEnd = src.indexOf('\n', start);
            if (lineEnd === -1) {
              // Incomplete fence start; replace tail with placeholder
              out += placeholder;
              i = src.length;
              break;
            }

            // Find closing fence line (starts a line).
            let close = src.indexOf('\n```', lineEnd + 1);
            while (close !== -1) {
              const after = close + 4;
              if (after >= src.length) break;
              const ch = src[after];
              if (ch === '\n') break;
              if (ch === '\r' && src[after + 1] === '\n') break;
              close = src.indexOf('\n```', close + 1);
            }

            if (close === -1) {
              // Incomplete flow block; replace tail with placeholder
              out += placeholder;
              i = src.length;
              break;
            }

            // Skip the entire flow block (closed) and insert placeholder
            out += placeholder;

            // Advance past closing fence line
            i = close + 4;
            if (src[i] === '\r' && src[i + 1] === '\n') i += 2;
            else if (src[i] === '\n') i += 1;
          }

          out += src.slice(i);
          t = out;
        })();

        // Fenced code blocks: don't render until closed.
        // If fence count is odd, break the last fence so it is treated as plain text.
        const fence = '```';
        const fenceCount = (t.match(/```/g) || []).length;
        if (fenceCount % 2 === 1) {
          const last = t.lastIndexOf(fence);
          if (last !== -1) {
            // Insert a zero-width space inside the fence to prevent markdown parsing,
            // while keeping it visually identical to ``` for the user.
            const brokenFence = '``\u200b`';
            t = t.slice(0, last) + brokenFence + t.slice(last + fence.length);
          }
        }

        // Tables: treat as unstable until a blank line appears after the last row.
        // We suppress a trailing (still-growing) table by escaping pipes in the trailing table region.
        try {
          const lines = t.split('\n');
          const sepRe = /^\s*\|?\s*:?-+:?\s*(\|\s*:?-+:?\s*)+\|?\s*$/; // markdown table separator
          const rowRe = /^\s*\|.*\|\s*$/; // simple row heuristic
          let sepLineIdx = -1;
          for (let i = lines.length - 1; i >= 0; i--) {
            if (sepRe.test(lines[i] || '')) { sepLineIdx = i; break; }
          }
          if (sepLineIdx !== -1) {
            // Find table start: walk upward from header/separator through contiguous table-like lines
            let tableStart = Math.max(0, sepLineIdx - 1);
            while (tableStart > 0) {
              const prev = lines[tableStart - 1] || '';
              if (prev.trim() === '') break;
              // allow header rows, separator, and pipe rows
              if (rowRe.test(prev) || sepRe.test(prev)) {
                tableStart -= 1;
                continue;
              }
              break;
            }

            // Find table end: walk downward through contiguous table-like lines
            let tableEnd = sepLineIdx;
            while (tableEnd + 1 < lines.length) {
              const nxt = lines[tableEnd + 1] || '';
              if (nxt.trim() === '') break;
              if (rowRe.test(nxt) || sepRe.test(nxt)) {
                tableEnd += 1;
                continue;
              }
              break;
            }

            const terminatorLine = lines[tableEnd + 1] || '';
            const hasTerminator = (terminatorLine.trim() === '') || (!!terminatorLine && !(rowRe.test(terminatorLine) || sepRe.test(terminatorLine)));

            // If the table touches the end of the current streamed text and has no terminator yet,
            // keep it as plain text to avoid half-rendered tables.
            if (!hasTerminator && tableEnd >= lines.length - 1) {
              for (let j = tableStart; j < lines.length; j++) {
                lines[j] = (lines[j] || '').replaceAll('|', '&#124;');
              }
              t = lines.join('\n');
            }
          }
        } catch (_) {}

        return t;
      }

      function updateAssistantPendingText(pendingId, text) {
        const node = messagesEl.querySelector?.(`[data-chatbot-pending="${pendingId}"]`);
        if (!node) return;
        const bubble = node.querySelector?.('div');
        if (!bubble) return;

        // Store latest accumulated text and batch DOM updates
        bubble._streamAccumulatedText = String(text || '');
        if (bubble._streamRaf) return;

        bubble._streamRaf = requestAnimationFrame(() => {
          bubble._streamRaf = null;

          const msg = bubble._streamAccumulatedText || '';
          const safe = safeMarkdownForStreaming(msg);
          if (safe === bubble._lastStreamSafeText) return;
          bubble._lastStreamSafeText = safe;

          // Keep it in normal (non-error) style while streaming
          bubble.classList.remove('bg-danger', 'text-white');
          bubble.classList.add('bg-body-secondary');
          bubble.classList.add('markdown-content');

          try {
            if (window.marked && window.DOMPurify && typeof window.marked.parse === 'function') {
              // Stable-only tags during streaming (no script; diagrams are placeholders only)
              const allowedTags = [
                'p', 'br', 'strong', 'em', 'u', 's',
                'code',
                'ul', 'ol', 'li',
                'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                'blockquote', 'a', 'hr',
                'div'
              ];

              let rawHtml = '';
              try {
                rawHtml = window.marked.parse(safe);
              } catch (_) {
                rawHtml = escapeHtml(safe).replace(/\n/g, '<br>');
              }

              const cleanHtml = window.DOMPurify.sanitize(rawHtml, {
                ALLOWED_TAGS: allowedTags,
                ALLOWED_ATTR: ['href', 'title', 'target', 'rel', 'class', 'style'],
                KEEP_CONTENT: true
              });

              bubble.innerHTML = cleanHtml;

              // Safe link behavior
              bubble.querySelectorAll?.('a[href]')?.forEach(a => {
                a.setAttribute('target', '_blank');
                a.setAttribute('rel', 'noopener noreferrer');
              });
            } else {
              // Deps not ready: still avoid raw token phase; render as escaped HTML with <br>
              bubble.innerHTML = escapeHtml(safe).replace(/\n/g, '<br>');
            }
          } catch (_) {
            bubble.innerHTML = escapeHtml(safe).replace(/\n/g, '<br>');
          }
        });
      }

      async function sendTextMessage(text) {
        const trimmed = (text || '').trim();
        if (!trimmed) return;

        if (!window.visionAPI || typeof window.visionAPI.isAuthenticated !== 'function') {
          return;
        }

        const active = getActive();
        if (!active) return;

        const mode = getMode();
        const state = active.mode[mode];

        // On first message per tab+mode, remove the initial welcome/suggestions content
        if (!state.started) {
          state.started = true;
          messagesEl.innerHTML = '';
        }

        const ok = appendUserBubble(trimmed);
        if (!ok) return;
        const pendingId = appendAssistantPending();
        saveActiveHtml();
        // Always keep view pinned to bottom
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
          // ------------------------------------------------------------
          // DEMO MODE (no-backend): useful to debug chart rendering/resizing
          // Commands:
          // - "demo on"  â†’ enable demo mode
          // - "demo off" â†’ disable demo mode
          // - (chart demo removed)
          // ------------------------------------------------------------
          const DEMO_KEY = 'chatbot_demo_mode';
          const lower = trimmed.toLowerCase();

          if (lower === 'demo on' || lower === '/demo on') {
            localStorage.setItem(DEMO_KEY, 'true');
            replaceAssistantPending(pendingId, '**Demo mode enabled** (backend calls are disabled). Type `demo off` to exit.');
            state.html = messagesEl.innerHTML;
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return;
          }
          if (lower === 'demo off' || lower === '/demo off') {
            localStorage.setItem(DEMO_KEY, 'false');
            replaceAssistantPending(pendingId, '**Demo mode disabled** (backend calls are enabled again).');
            state.html = messagesEl.innerHTML;
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return;
          }

          const demoEnabled = localStorage.getItem(DEMO_KEY) === 'true';
          if (demoEnabled) {
            // Demo mode kept for quick backend-off testing; Mermaid demo removed.
            replaceAssistantPending(pendingId, `**Demo mode** is ON. Backend calls are disabled.\n\nYou said: \`${escapeHtml(trimmed)}\``);
            state.html = messagesEl.innerHTML;
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return;
          }

          if (!window.visionAPI.isAuthenticated()) {
            throw new Error('Please login first.');
          }

          // Cancel any in-flight stream for this tab+mode
          try { state._abortController?.abort?.(); } catch (_) {}
          state._abortController = new AbortController();

          let acc = '';
          let finalPayload = null;
          let sawError = false;

          const stream = (mode === 'agent')
            ? window.visionAPI.chatWithAgentStream(trimmed, state.sessionId, null, null, state._abortController.signal)
            : window.visionAPI.generalChatStream(trimmed, state.sessionId, state._abortController.signal);

          for await (const evt of stream) {
            const evName = evt?.event || 'message';
            const data = evt?.data;

            if (evName === 'meta') {
              const sid = data?.session_id || null;
              if (sid) state.sessionId = sid;
              continue;
            }

            if (evName === 'token') {
              const delta = data?.delta != null ? String(data.delta) : '';
              if (delta) {
                acc += delta;
                // ChatGPT-style micro-batching:
                // Only trigger a render on meaningful boundaries, plus a periodic flush.
                const boundary = /[\s.,!?;:\n]/.test(delta);
                const now = Date.now();
                const last = state._lastStreamUiFlushTs || 0;
                const shouldFlush = boundary || (now - last) > 200;
                if (shouldFlush) {
                  state._lastStreamUiFlushTs = now;

                  // Scroll anchoring: only auto-scroll if user is already near bottom
                  const distanceFromBottom = messagesEl.scrollHeight - (messagesEl.scrollTop + messagesEl.clientHeight);
                  const shouldAutoScroll = distanceFromBottom < 60;

                  updateAssistantPendingText(pendingId, acc);
                  state.html = messagesEl.innerHTML;
                  if (shouldAutoScroll) {
                    messagesEl.scrollTop = messagesEl.scrollHeight;
                  }
                }
              }
              continue;
            }

            if (evName === 'error') {
              sawError = true;
              // keep streaming; final "done" will close out
              continue;
            }

            if (evName === 'done') {
              finalPayload = data;
              break;
            }
          }

          // Ensure we flush any remaining text even if last deltas had no boundaries
          if (acc) {
            updateAssistantPendingText(pendingId, acc);
          }

          const answer = finalPayload?.response ?? acc ?? '';
          const nextSessionId = finalPayload?.session_id ?? null;
          if (nextSessionId) state.sessionId = nextSessionId;

          const isError = (finalPayload?.status === 'error') || sawError;
          replaceAssistantPending(pendingId, answer || '(empty response)', isError);

          // Render flow diagram AFTER replacing so markdown is final
          if (!isError && finalPayload?.flow_diagram_data) {
            await renderFlowDiagram(pendingId, finalPayload.flow_diagram_data);
          }
          
          state.html = messagesEl.innerHTML;
          messagesEl.scrollTop = messagesEl.scrollHeight;
        } catch (err) {
          if (err && (err.name === 'AbortError' || String(err).includes('AbortError'))) {
            // Expected when a newer message cancels an in-flight stream
            return;
          }
          const msg = err?.message ? String(err.message) : 'Chat request failed.';
          replaceAssistantPending(pendingId, msg, true);
          state.html = messagesEl.innerHTML;
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }
      }

      // Events
      tabsEl.addEventListener('click', (e) => {
        const closeEl = e.target.closest?.('[data-chatbot-tab-close]');
        if (closeEl) {
          e.stopPropagation();
          const id = closeEl.getAttribute('data-chatbot-tab-close');
          if (id) closeTab(id);
          return;
        }

        const tabBtn = e.target.closest?.('[data-chatbot-tab-btn]');
        if (tabBtn) {
          const id = tabBtn.getAttribute('data-chatbot-tab-btn');
          if (id) showTab(id);
        }
      });

      newTabBtn?.addEventListener('click', () => createTab());

      sendBtn?.addEventListener('click', () => {
        if (!textarea) return;
        const text = textarea.value;
        textarea.value = '';
        textarea.dispatchEvent(new Event('input'));
        sendTextMessage(text);
      });

      document.addEventListener('click', (e) => {
        const el = e.target.closest?.('[data-chatbot-action="clear"]');
        if (!el) return;
        e.preventDefault();
        const active = getActive();
        if (!active) return;
        const mode = getMode();
        active.mode[mode] = emptyModeState();
        messagesEl.innerHTML = initialTemplate;
        saveActiveHtml();
      });

      document.addEventListener('click', (e) => {
        const el = e.target.closest?.('[data-chatbot-mode]');
        if (!el) return;
        e.preventDefault();
        const mode = el.getAttribute('data-chatbot-mode');
        if (!mode) return;
        setMode(mode);
      });

      // Voice (General only): click to start/stop recording
      (function initVoice() {
        if (!voiceBtn) return;
        let recorder = null;
        let chunks = [];
        let isRecording = false;

        async function start() {
          if (!navigator.mediaDevices?.getUserMedia) {
            throw new Error('Microphone not supported.');
          }
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          chunks = [];
          recorder = new MediaRecorder(stream);
          recorder.ondataavailable = (ev) => {
            if (ev.data && ev.data.size > 0) chunks.push(ev.data);
          };
          recorder.onstop = () => {
            // stop tracks
            stream.getTracks().forEach(t => t.stop());
          };
          recorder.start();
          isRecording = true;
          voiceBtn.classList.add('text-danger');
        }

        async function stopAndSend() {
          if (!recorder) return;
          const active = getActive();
          if (!active) return;
          if (!window.visionAPI?.isAuthenticated?.() ) throw new Error('Please login first.');
          if (getMode() !== 'general') throw new Error('Voice is available in General mode only.');

          const state = active.mode.general;

          // On first voice use per tab+general, remove welcome/suggestions
          if (!state.started) {
            state.started = true;
            messagesEl.innerHTML = '';
          }

          const stopped = new Promise(resolve => {
            recorder.addEventListener('stop', resolve, { once: true });
          });
          recorder.stop();
          await stopped;

          isRecording = false;
          voiceBtn.classList.remove('text-danger');

          const blob = new Blob(chunks, { type: 'audio/webm' });
          const file = new File([blob], 'voice.webm', { type: 'audio/webm' });

          // Render placeholders
          appendUserBubble('[Voice message]');
          const pendingId = appendAssistantPending();
          saveActiveHtml();
          messagesEl.scrollTop = messagesEl.scrollHeight;

          const result = await window.visionAPI.voiceChat(file, state.sessionId);
          if (result?.sessionId) state.sessionId = result.sessionId;
          const textResp = result?.textResponse || '(voice response)';
          replaceAssistantPending(pendingId, textResp);
          state.html = messagesEl.innerHTML;
          messagesEl.scrollTop = messagesEl.scrollHeight;

          // Play audio (best-effort)
          try {
            if (result?.audioBlob) {
              const url = URL.createObjectURL(result.audioBlob);
              const audio = new Audio(url);
              audio.play().catch(() => {});
              audio.onended = () => URL.revokeObjectURL(url);
            }
          } catch {}
        }

        voiceBtn.addEventListener('click', async () => {
          try {
            if (getMode() !== 'general') {
              // keep silent; user can switch mode
              return;
            }

            if (!isRecording) {
              await start();
            } else {
              await stopAndSend();
            }
          } catch (err) {
            isRecording = false;
            voiceBtn.classList.remove('text-danger');
            const active = getActive();
            if (active) {
              appendAssistantPending(); // ensures latest is visible even if template is empty
              const lastPending = messagesEl.querySelector?.('[data-chatbot-pending]');
              if (lastPending) {
                const bubble = lastPending.querySelector?.('div');
                if (bubble) {
                  bubble.textContent = err?.message ? String(err.message) : 'Voice failed.';
                  bubble.classList.remove('bg-body-secondary');
                  bubble.classList.add('bg-danger', 'text-white');
                }
              }
              active.mode.general.html = messagesEl.innerHTML;
              messagesEl.scrollTop = messagesEl.scrollHeight;
            }
          }
        });
      })();

      // Init with first tab
      chatbotOffcanvas.dataset.chatbotMode = chatbotOffcanvas.dataset.chatbotMode || 'general';
      if (modeLabel) modeLabel.textContent = getMode() === 'agent' ? 'Agent' : 'General';
      createTab('New chat 1');
    }

    function initChatbotKeyboardShortcut() {
      // Ctrl+L (or Cmd+L on Mac) to toggle chatbot
      document.addEventListener('keydown', function(e) {
        // Check for Ctrl+L (Windows/Linux) or Cmd+L (Mac)
        if ((e.ctrlKey || e.metaKey) && e.key === 'l' && !e.shiftKey && !e.altKey) {
          // Prevent default browser behavior (focus address bar)
          e.preventDefault();
          
          const chatbotOffcanvas = document.getElementById('chatbot-offcanvas');
          if (!chatbotOffcanvas || typeof bootstrap === 'undefined') return;
          
          const offcanvasInstance = bootstrap.Offcanvas.getInstance(chatbotOffcanvas);
          
          if (offcanvasInstance) {
            // Toggle: if open, close it; if closed, open it
            offcanvasInstance.toggle();
          } else {
            // Create new instance and show
            const newInstance = new bootstrap.Offcanvas(chatbotOffcanvas);
            newInstance.show();
          }
        }
      });
    }
    
    // Wait for DOM and Bootstrap to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        // Wait for Bootstrap to be available
        if (typeof bootstrap !== 'undefined') {
          initChatbotPush();
          initChatbotComposer();
          initChatbotTabs();
          initChatbotKeyboardShortcut();
        } else {
          // Wait a bit more for Bootstrap to load
          setTimeout(function() {
            if (typeof bootstrap !== 'undefined') {
              initChatbotPush();
              initChatbotComposer();
              initChatbotTabs();
              initChatbotKeyboardShortcut();
            }
          }, 100);
        }
      });
    } else {
      // DOM already loaded
      if (typeof bootstrap !== 'undefined') {
        initChatbotPush();
        initChatbotComposer();
        initChatbotTabs();
        initChatbotKeyboardShortcut();
      } else {
        setTimeout(function() {
          if (typeof bootstrap !== 'undefined') {
            initChatbotPush();
            initChatbotComposer();
            initChatbotTabs();
            initChatbotKeyboardShortcut();
          }
        }, 100);
      }
    }
  })();
</script>

