<!-- Chatbot Styles -->
<style>
  /* Global Viewport Constraints - Body is now neutral */
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    overflow: hidden;
    /* Body is just a container, no layout */
  }

  /* Chatbot Grid Layout States - Applied to #app-root */
  #app-root.chatbot-open {
    display: grid !important;
    /* Force grid layout */
    grid-template-columns:
      var(--phoenix-navbar-vertical-width, 280px) 1fr var(--chatbot-width, 400px);
    /* Ensure rows don't blow up */
    grid-template-rows: auto 1fr;
    /* If row 2 is 1fr, it takes remaining space. */
  }

  #app-root.chatbot-expanded {
    display: grid !important;
    grid-template-columns:
      var(--phoenix-navbar-vertical-width, 280px) 1fr var(--chatbot-width, 400px);
    grid-template-rows: auto 1fr;
  }

  /* When chatbot is expanded (>400px), keep content width as if chatbot were 400px.
     The viewport (middle column) is narrower, so horizontal scroll reveals the
     "extra hidden" area without creating empty margin space. */
  .viewport-scrolls.chatbot-expanded .content {
    min-width: calc(100% + var(--chatbot-excess, 0px));
  }

  /* Chatbot container - THE ACTUAL GRID ITEM */
  #chatbot-container {
    grid-column: 3;
    grid-row: 2;
    /* CRITICAL: Only span content row (row 2), NOT navbar row (row 1) */
    /* This is the constrained grid child that prevents overflow */
    height: 100%;
    min-height: 0;
    overflow: hidden;
    display: flex;
  }

  /* Chatbot panel - Flex child of container, NOT a grid item */
  #chatbot-offcanvas {
    /* REMOVED: grid-column, grid-row (not a grid item anymore) */
    position: relative !important;
    transform: none !important;
    visibility: visible !important;
    background-color: var(--phoenix-body-highlight-bg);
    border-left: 1px solid var(--phoenix-border-color);
    box-shadow: var(--phoenix-box-shadow);
    z-index: 1045;
    min-width: 300px;
    max-width: 1200px;
    transition: width 0.2s ease;
    display: none;

    /* STERN HEIGHT CONSTRAINTS */
    height: 100% !important;
    max-height: 100% !important;
    min-height: 0 !important;
    /* CRITICAL for Flex Item shrinking */

    /* IMPORTANT: prevent the entire panel from scrolling.
       Only the messages area should scroll so the input stays pinned. */
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  #chatbot-offcanvas.show {
    display: flex !important;
    flex-direction: column;
  }

  /* Make header/body/footer a proper fixed layout inside the offcanvas */
  #chatbot-offcanvas .offcanvas-header {
    flex: 0 0 auto;
  }

  #chatbot-offcanvas .offcanvas-body {
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    padding: 0 !important;
  }

  #chatbot-offcanvas .chat {
    flex: 1 1 auto;
    min-height: 0;
    display: flex;
    flex-direction: column;
  }

  #chatbot-offcanvas .chat-messages {
    flex: 1 1 auto;
    min-height: 0;
    overflow-y: auto;
    overflow-x: hidden;
  }

  #chatbot-offcanvas .card-footer {
    flex: 0 0 auto;
    /* Let the flex layout pin the footer; avoids sticky reflow issues when textarea height changes */
    position: relative;
    background: var(--phoenix-body-highlight-bg);
    z-index: 2;
  }

  [dir="rtl"] #chatbot-offcanvas {
    border-left: none;
    border-right: 1px solid var(--phoenix-border-color, #e9ecef);
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
  }

  /* Hide Bootstrap offcanvas backdrop */
  .offcanvas-backdrop {
    display: none !important;
  }

  /* Chatbot input (textarea) */
  #chatbot-input {
    resize: none;
    overflow-y: auto;
    /* scroll after max lines */
    line-height: 1.4;
    max-height: 96px;
    /* ~4 lines (JS autosize also enforces) */
  }

  /* Viewport horizontal scroll when chatbot expanded */
  .viewport-scrolls.chatbot-expanded {
    overflow-x: auto;
  }

  /* Chatbot Resize Handle */
  .chatbot-resize-handle {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 8px;
    cursor: col-resize;
    z-index: 1051;
    background: transparent;
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
  }

  [dir="rtl"] .chatbot-resize-handle {
    left: auto;
    right: 0;
  }

  body.chatbot-resizing {
    cursor: col-resize !important;
    user-select: none !important;
  }

  body.chatbot-resizing * {
    cursor: col-resize !important;
  }

  /* Disable ALL layout transitions while resizing to prevent "shaking" */
  /* VS Code pattern: Never animate layout during drag, only on release */
  body.chatbot-resizing #app-root {
    transition: none !important;
    /* CRITICAL: Disable grid-template-columns animation during resize */
  }

  body.chatbot-resizing #chatbot-container {
    transition: none !important;
    /* Disable container transitions */
  }

  body.chatbot-resizing #chatbot-offcanvas {
    transition: none !important;
    /* CRITICAL: Disable width animation during resize */
  }

  body.chatbot-resizing .viewport-scrolls,
  body.chatbot-resizing .content {
    transition: none !important;
    /* Disable content width/min-width animations while dragging */
  }

  .chatbot-resize-handle:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }

  .chatbot-resize-handle:active {
    background-color: rgba(0, 0, 0, 0.1);
  }

  .resize-handle-line {
    width: 2px;
    height: 40px;
    background-color: var(--phoenix-border-color, #e9ecef);
    border-radius: 2px;
    transition: background-color 0.2s ease;
  }

  .chatbot-resize-handle:hover .resize-handle-line {
    background-color: var(--phoenix-primary, #2A7BE4);
  }

  /* Ensure body doesn't get overflow hidden from Bootstrap */
  body.modal-open:has(#chatbot-offcanvas.show) {
    overflow: hidden !important;
    padding-right: 0 !important;
  }

  /* -----------------------------
     Chat header tabs (Phoenix/Bootstrap)
     ----------------------------- */
  #chatbot-offcanvas .chatbot-tabs {
    overflow-x: auto;
    white-space: nowrap;
    scrollbar-width: thin;
  }

  #chatbot-offcanvas .chatbot-tabs .nav-link {
    display: inline-flex;
    align-items: center;
  }

  #chatbot-offcanvas .chatbot-tab-name {
    max-width: 180px;
  }

  #chatbot-offcanvas .chatbot-tab-close {
    opacity: 0;
    pointer-events: none;
  }

  #chatbot-offcanvas .nav-item:hover .chatbot-tab-close {
    opacity: 1;
    pointer-events: auto;
  }

  /* Remove inline styles by mapping to classes */
  #chatbot-offcanvas .card-body.chat {
    min-height: 0;
  }

  .setting-toggle {
    margin-top: -120px;
  }

  .chatbot-toggle-icon {
    height: 34px;
    width: 28px;
  }

  /* -----------------------------
     Modern Chatbot Input UI
     ----------------------------- */
  #chatbot-offcanvas .chatbot-input-container {
    background-color: var(--phoenix-emphasis-bg);
    border: 1px solid var(--phoenix-border-color);
    border-radius: 1.25rem;
    padding: 0.75rem 1rem;
    position: relative;
    /* Context for absolute controls */
    display: block;
    min-height: 84px;
    /* Sufficient height for textarea + controls */
    transition: background-color 0.2s, border-color 0.2s;
  }

  [data-bs-theme="dark"] #chatbot-offcanvas .chatbot-input-container {
    border-color: var(--phoenix-border-color);
  }

  /* Textarea styling */
  #chatbot-offcanvas #chatbot-input {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0;
    resize: none;
    min-height: 24px;
    max-height: 200px;
    width: 100%;
    /* Reserve space for the absolute position controls below */
    margin-bottom: 2.75rem;
  }

  #chatbot-offcanvas #chatbot-input:focus {
    outline: none !important;
  }

  /* Controls Area - Pinned Absolute Bottom */
  .chatbot-controls-area {
    position: absolute;
    bottom: 0.5rem;
    left: 1rem;
    right: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 32px;
    /* Fixed height for stability */
  }

  .chatbot-btn-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  /* Dropdown Toggles (Agent, Auto) */
  .chatbot-pill-btn {
    border-radius: 50rem;
    padding: 0.25rem 0.6rem;
    font-size: 0.75rem;
    font-weight: 600;
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--phoenix-body-color);
    border: none;
    display: flex;
    align-items: center;
    gap: 0.35rem;
    transition: all 0.2s;
  }

  .chatbot-pill-btn:hover {
    background-color: rgba(0, 0, 0, 0.1);
  }

  [data-bs-theme="dark"] .chatbot-pill-btn {
    background-color: rgba(255, 255, 255, 0.1);
    color: #eee;
  }

  [data-bs-theme="dark"] .chatbot-pill-btn:hover {
    background-color: rgba(255, 255, 255, 0.15);
  }

  /* Right Side Icons */
  .chatbot-action-icon {
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    border: none;
    background: transparent;
    color: var(--phoenix-body-color-tertiary);
    transition: all 0.2s;
  }

  .chatbot-action-icon:hover {
    color: var(--phoenix-primary);
    background-color: rgba(var(--phoenix-primary-rgb), 0.1);
  }

  /* Send Button / Voice Assistant Button (Dynamic) */
  .chatbot-send-btn {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--phoenix-body-color);
    /* Adaptive black/white */
    color: var(--phoenix-body-bg);
    transition: transform 0.1s, background-color 0.2s, color 0.2s;
  }

  .chatbot-send-btn:hover {
    transform: scale(1.05);
  }

  .chatbot-send-btn:active {
    transform: scale(0.95);
  }

  [data-bs-theme="dark"] .chatbot-send-btn {
    background-color: #fff;
    color: #000;
  }

  /* Voice Assistant State (when textarea is empty) */
  .chatbot-send-btn.voice-assistant-state {
    background-color: #fff;
    color: #000;
  }

  [data-bs-theme="dark"] .chatbot-send-btn.voice-assistant-state {
    background-color: #fff;
    color: #000;
  }

  /* Recording state */
  .chatbot-send-btn.recording {
    background-color: #dc3545 !important;
    color: #fff !important;
    animation: pulse-recording 1.5s ease-in-out infinite;
  }

  @keyframes pulse-recording {

    0%,
    100% {
      opacity: 1;
    }

    50% {
      opacity: 0.7;
    }
  }

  /* Audio wave icon styling */
  .chatbot-send-btn .voice-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2px;
  }

  /* Send icon styling */
  .chatbot-send-btn .send-icon {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .chatbot-send-btn .voice-icon-bar {
    width: 3px;
    background-color: currentColor;
    border-radius: 2px;
    transition: height 0.2s;
  }

  .chatbot-send-btn .voice-icon-bar:nth-child(1) {
    height: 8px;
  }

  .chatbot-send-btn .voice-icon-bar:nth-child(2) {
    height: 12px;
  }

  .chatbot-send-btn .voice-icon-bar:nth-child(3) {
    height: 10px;
  }

  /* -----------------------------
     Chat Message Bubbles (Phoenix UI Style)
     ----------------------------- */
  /* User message bubbles - subtle background */
  /* User message bubbles - subtle background */
  #chatbot-offcanvas .chat-messages .user-message {
    background: var(--phoenix-emphasis-bg);
    border-radius: 0.6rem;
    padding: 0.75rem 1rem;
    width: fit-content;
  }

  /* Wrapper handles the max-width and structural layout */
  #chatbot-offcanvas .chat-messages .user-message-wrapper {
    max-width: 75%;
    width: fit-content;
  }

  [data-bs-theme="dark"] #chatbot-offcanvas .chat-messages .user-message {
    border-color: var(--phoenix-border-color);
  }

  /* AI message bubbles - transparent background, text only */
  #chatbot-offcanvas .chat-messages .ai-message-transparent {
    background: transparent !important;
    padding: 0.5rem 0;
    max-width: 85%;
  }

  /* AI message action buttons */
  #chatbot-offcanvas .chat-messages .ai-message-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
    opacity: 0.7;
  }

  #chatbot-offcanvas .chat-messages .ai-message-actions button {
    background: transparent;
    border: none;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    color: var(--phoenix-body-color-tertiary);
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  #chatbot-offcanvas .chat-messages .ai-message-actions button:hover {
    background: var(--phoenix-body-highlight-bg, rgba(0, 0, 0, 0.05));
    color: var(--phoenix-body-color);
  }

  [data-bs-theme="dark"] #chatbot-offcanvas .chat-messages .ai-message-actions button:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  /* User message action buttons - hidden by default, shown on hover */
  #chatbot-offcanvas .chat-messages .user-message-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
    opacity: 0;
    transition: opacity 0.2s;
  }

  #chatbot-offcanvas .chat-messages .user-message-wrapper:hover .user-message-actions {
    opacity: 0.7;
  }

  #chatbot-offcanvas .chat-messages .user-message-actions button {
    background: transparent;
    border: none;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    color: var(--phoenix-body-color-tertiary);
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  #chatbot-offcanvas .chat-messages .user-message-actions button:hover {
    background: var(--phoenix-body-highlight-bg, rgba(0, 0, 0, 0.05));
    color: var(--phoenix-body-color);
  }

  [data-bs-theme="dark"] #chatbot-offcanvas .chat-messages .user-message-actions button:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  /* -----------------------------
     Markdown rendering inside assistant bubbles
     ----------------------------- */
  #chatbot-offcanvas .chat-messages .markdown-content {
    /* allow markdown HTML to wrap nicely */
    word-break: break-word;
  }

  #chatbot-offcanvas .chat-messages .markdown-content p {
    margin: 0.5rem 0;
    line-height: 1.5;
  }

  #chatbot-offcanvas .chat-messages .markdown-content p:first-child {
    margin-top: 0;
  }

  #chatbot-offcanvas .chat-messages .markdown-content p:last-child {
    margin-bottom: 0;
  }

  #chatbot-offcanvas .chat-messages .markdown-content code {
    background-color: rgba(0, 0, 0, 0.08);
    padding: 0.15em 0.35em;
    border-radius: 4px;
    font-size: 0.92em;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  #chatbot-offcanvas .chat-messages .markdown-content pre {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 0.75rem;
    border-radius: 0.5rem;
    overflow-x: auto;
    margin: 0.6rem 0;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 0.9em;
  }

  #chatbot-offcanvas .chat-messages .markdown-content pre code {
    background: transparent;
    padding: 0;
  }

  #chatbot-offcanvas .chat-messages .markdown-content ul,
  #chatbot-offcanvas .chat-messages .markdown-content ol {
    margin: 0.5rem 0;
    padding-left: 1.25rem;
  }

  #chatbot-offcanvas .chat-messages .markdown-content li {
    margin: 0.2rem 0;
    line-height: 1.5;
  }

  #chatbot-offcanvas .chat-messages .markdown-content blockquote {
    border-left: 3px solid rgba(0, 0, 0, 0.2);
    padding-left: 0.75rem;
    margin: 0.5rem 0;
    color: rgba(0, 0, 0, 0.75);
    font-style: italic;
  }

  #chatbot-offcanvas .chat-messages .markdown-content a {
    color: var(--phoenix-primary, #2A7BE4);
    text-decoration: underline;
  }

  #chatbot-offcanvas .chat-messages .markdown-content a:hover {
    text-decoration: none;
  }

  #chatbot-offcanvas .chat-messages .markdown-content hr {
    border: 0;
    border-top: 1px solid rgba(0, 0, 0, 0.12);
    margin: 0.75rem 0;
  }

  #chatbot-offcanvas .chat-messages .markdown-content table {
    border-collapse: collapse;
    width: 100%;
    margin: 0.5rem 0;
    font-size: 0.92em;
  }

  #chatbot-offcanvas .chat-messages .markdown-content th,
  #chatbot-offcanvas .chat-messages .markdown-content td {
    border: 1px solid rgba(0, 0, 0, 0.12);
    padding: 0.35rem 0.5rem;
    text-align: left;
    vertical-align: top;
  }

  #chatbot-offcanvas .chat-messages .markdown-content th {
    background: rgba(0, 0, 0, 0.04);
    font-weight: 600;
  }

  /* (Mermaid removed) */

  /* -----------------------------
     Rete.js-Style Flow Diagram Styles
     ----------------------------- */
  .flow-diagram-container {
    margin: 16px 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    /* Fixed visual area: diagram fits via SVG viewBox, no page scrolling */
    height: clamp(240px, 45vh, 560px);
    /* Theme-aware colors (Phoenix/Bootstrap variables) */
    --flow-bg: var(--bs-emphasis-bg, #f8f9fa);
    --flow-border: rgba(var(--bs-border-color-rgb, 222, 226, 230), 0.9);
    --flow-edge-color: rgba(var(--bs-body-color-rgb, 33, 37, 41), 0.45);
    --flow-label-color: rgba(var(--bs-body-color-rgb, 33, 37, 41), 0.85);
    --flow-label-bg: var(--bs-body-bg, #fff);
    background: var(--flow-bg);
    border: 1px solid var(--flow-border);
    position: relative;
  }

  /* (Toolbar removed as requested) */

  /* Node styles */
  .flow-node {
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .flow-node .node-shape {
    transition: all 0.2s ease;
  }

  .flow-node:hover .node-shape {
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
  }

  .flow-node.active .node-shape {
    filter: drop-shadow(0 0 12px rgba(42, 123, 228, 0.8));
    stroke: #2A7BE4 !important;
    stroke-width: 3 !important;
  }

  /* Connection styles */
  .flow-connection {
    transition: all 0.2s ease;
  }

  .flow-connection .connection-path {
    transition: all 0.2s ease;
  }

  .flow-connection:hover .connection-path {
    stroke: #2A7BE4;
    stroke-width: 3;
  }

  .flow-connection.active .connection-path {
    stroke: #2A7BE4;
    stroke-width: 3;
    stroke-dasharray: 8 6;
    animation: flowConnectionDash 1s linear infinite;
  }

  .flow-connection.active .connection-arrow {
    fill: #2A7BE4;
  }

  @keyframes flowConnectionDash {
    from {
      stroke-dashoffset: 0;
    }

    to {
      stroke-dashoffset: -28;
    }
  }

  /* Connection labels */
  .connection-label {
    pointer-events: none;
    user-select: none;
  }

  /* Node labels */
  .node-label {
    pointer-events: none;
    user-select: none;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .flow-diagram-container {
      margin: 12px 0;
    }

    .flow-node .node-label {
      font-size: 9px !important;
    }

    .connection-label {
      font-size: 8px !important;
    }
  }

  /* -----------------------------
     Zone drawing (snapshot + polygon)
     ----------------------------- */
  .zone-editor {
    margin-top: 0.75rem;
    border: 1px solid rgba(0, 0, 0, 0.12);
    border-radius: 0.75rem;
    overflow: hidden;
    background: var(--phoenix-body-bg, #fff);
  }

  .zone-editor__header {
    padding: 0.65rem 0.75rem;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
  }

  .zone-editor__title {
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--phoenix-body-color, #212529);
  }

  .zone-editor__body {
    padding: 0.75rem;
  }

  .zone-editor__canvas-wrap {
    position: relative;
    width: 100%;
    border-radius: 0.6rem;
    overflow: hidden;
    background: rgba(0, 0, 0, 0.04);
    border: 1px solid rgba(0, 0, 0, 0.08);
  }

  .zone-editor__img {
    display: block;
    width: 100%;
    height: auto;
    user-select: none;
    -webkit-user-select: none;
    pointer-events: none;
    /* all interactions go to overlay canvas */
  }

  .zone-editor__canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    cursor: crosshair;
  }

  .zone-editor__hint {
    color: rgba(0, 0, 0, 0.65);
    font-size: 0.82rem;
    margin-top: 0.6rem;
  }

  .zone-editor__actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 0.6rem;
  }

  .zone-editor__actions .btn {
    font-size: 0.82rem;
  }
</style>

<!-- Chatbot Offcanvas - Pushes main content instead of overlaying -->
<div class="offcanvas offcanvas-end chatbot-panel border-0" id="chatbot-offcanvas" tabindex="-1"
  aria-labelledby="chatbot-offcanvas" data-bs-backdrop="false" data-bs-scroll="true">
  <!-- Resize Handle -->
  <div class="chatbot-resize-handle" id="chatbot-resize-handle" title="Drag to resize">
    <div class="resize-handle-line"></div>
  </div>
  <div
    class="offcanvas-header border-bottom border-translucent px-3 py-2 d-flex align-items-center justify-content-between gap-2">
    <!-- Left: Chat tabs -->
    <ul class="nav nav-underline fs-9 flex-nowrap overflow-x-auto chatbot-tabs me-2" id="chatbot-tabs" role="tablist"
      aria-label="Chat tabs">
      <!-- Tabs injected by JS -->
    </ul>

    <!-- Right: Actions -->
    <div class="d-flex align-items-center gap-2 flex-shrink-0">
      <button class="btn btn-link p-0 d-flex align-items-center" type="button" id="chatbot-new-tab"
        aria-label="New chat tab" title="New chat">
        <span class="fas fa-plus text-body"></span>
      </button>

      <div class="dropdown">
        <button class="btn btn-link p-0 dropdown-toggle dropdown-caret-none transition-none d-flex align-items-center"
          type="button" id="chatbot-history-dropdown" data-bs-toggle="dropdown" data-boundary="window"
          aria-haspopup="true" aria-expanded="false" aria-label="Chat history" title="Chat history">
          <span class="far fa-clock text-body"></span>
        </button>
        <div class="dropdown-menu dropdown-menu-end py-2" aria-labelledby="chatbot-history-dropdown">
          <h6 class="dropdown-header">Chat history (dummy)</h6>
          <a class="dropdown-item" href="#!">New chat 1 â€” Camera status</a>
          <a class="dropdown-item" href="#!">New chat 2 â€” Events today</a>
          <a class="dropdown-item" href="#!">New chat 3 â€” Agent settings</a>
          <div class="dropdown-divider"></div>
          <a class="dropdown-item text-body-tertiary" href="#!">Later weâ€™ll connect realtime history</a>
        </div>
      </div>

      <div class="btn-reveal-trigger">
        <button class="btn btn-link p-0 dropdown-toggle dropdown-caret-none transition-none d-flex align-items-center"
          type="button" id="chatbot-dropdown" data-bs-toggle="dropdown" data-boundary="window" aria-haspopup="true"
          aria-expanded="false" data-bs-reference="parent" aria-label="More options" title="More options">
          <span class="fas fa-ellipsis-h text-body"></span>
        </button>
        <div class="dropdown-menu dropdown-menu-end py-2" aria-labelledby="chatbot-dropdown">
          <a class="dropdown-item" href="#!" data-chatbot-action="clear">Clear chat</a>
          <a class="dropdown-item" href="#!">Search in chat</a>
          <a class="dropdown-item" href="#!">Show history</a>
          <a class="dropdown-item" href="#!">Settings</a>
        </div>
      </div>

      <button class="btn p-1 fw-bolder" type="button" data-bs-dismiss="offcanvas" aria-label="Close">
        <span class="fas fa-times fs-8"></span>
      </button>
    </div>
  </div>
  <div class="offcanvas-body p-0 d-flex flex-column">
    <div class="card-body chat p-0 flex-1 d-flex flex-column">
      <div class="chat-messages d-flex flex-column scrollbar h-100 p-3">
        <!-- Intentionally blank: we don't show any welcome/suggestion content -->
      </div>
    </div>
    <div class="card-footer px-3 py-3" style="background: transparent;">
      <!-- Modern Chatbot Input Container -->
      <div class="chatbot-input-container">

        <!-- Top: Text Input -->
        <!-- Note: Rows=1 but JS autosize handles expansion -->
        <textarea class="form-control fs-9" placeholder="Message Agent..." id="chatbot-input" rows="1"></textarea>

        <!-- Bottom: Controls -->
        <div class="chatbot-controls-area">

          <!-- Left Actions -->
          <div class="chatbot-btn-group">
            <!-- Agent Dropdown -->
            <div class="dropdown">
              <button class="btn chatbot-pill-btn dropdown-toggle dropdown-caret-none" type="button"
                id="chatbot-mode-dropdown" data-bs-toggle="dropdown" aria-expanded="false">
                <span class="fas fa-infinity fs-10"></span>
                <span id="chatbot-mode-label">Agent</span>
                <span class="fas fa-chevron-down fs-11 opacity-50"></span>
              </button>
              <ul class="dropdown-menu" aria-labelledby="chatbot-mode-dropdown">
                <li><a class="dropdown-item" href="#!" data-chatbot-mode="general">General</a></li>
                <li><a class="dropdown-item" href="#!" data-chatbot-mode="agent">Agent</a></li>
              </ul>
            </div>

            <!-- Auto Toggle (Placeholder/Mockup for now) -->
            <button class="btn chatbot-pill-btn" type="button">
              <span>Auto</span>
              <span class="fas fa-chevron-down fs-11 opacity-50"></span>
            </button>
          </div>

          <!-- Right Actions -->
          <div class="chatbot-btn-group ms-auto">
            <!-- Loading/Processing Indicator (Static for now) -->
            <button class="chatbot-action-icon" title="Processing">
              <span class="fas fa-circle-notch fa-spin fs-10 opacity-50"></span>
            </button>

            <button class="chatbot-action-icon" title="Mention (@)">
              <span class="fas fa-at fs-9"></span>
            </button>

            <button class="chatbot-action-icon" title="Search Web">
              <span class="fas fa-globe fs-9"></span>
            </button>

            <button class="chatbot-action-icon" title="Upload Image">
              <span class="far fa-image fs-9"></span>
            </button>

            <!-- Send Button / Voice Assistant Button (Dynamic) -->
            <button class="chatbot-send-btn send-btn ms-2 voice-assistant-state" type="button"
              aria-label="Voice Assistant" title="Voice Assistant">
              <!-- Voice Assistant Icon (shown when textarea is empty) -->
              <span class="voice-icon">
                <span class="voice-icon-bar"></span>
                <span class="voice-icon-bar"></span>
                <span class="voice-icon-bar"></span>
              </span>
              <!-- Send Icon (shown when textarea has text) -->
              <span class="send-icon" style="display: none;">
                <span class="fas fa-arrow-up fs-9"></span>
              </span>
            </button>
          </div>

        </div>
      </div>
    </div>
  </div>
</div>

<!-- Toggle Button for Chatbot -->
<a class="card setting-toggle" href="#chatbot-offcanvas" data-bs-toggle="offcanvas" aria-controls="chatbot-offcanvas">
  <div class="card-body d-flex align-items-center px-3 py-2">
    <div class="position-relative rounded-start chatbot-toggle-icon">
      <div class="settings-popover"><span class="ripple"><span
            class="fa-spin position-absolute all-0 d-flex flex-center"><span
              class="icon-spin position-absolute all-0 d-flex flex-center">
              <svg width="20" height="20" viewBox="0 0 20 20" fill="#ffffff" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M10 2C5.58 2 2 5.58 2 10c0 1.54.36 2.98 1 4.28L1 19l4.72-1c1.3.64 2.74 1 4.28 1 4.42 0 8-3.58 8-8s-3.58-8-8-8zm0 14.5c-1.19 0-2.38-.31-3.34-.84l-.24-.12-2.5.65.65-2.5-.12-.24C4.31 12.38 4 11.19 4 10c0-3.31 2.69-6 6-6s6 2.69 6 6-2.69 6-6 6z"
                  fill="#2A7BE4"></path>
              </svg></span></span></span></div>
    </div><small class="text-uppercase text-body-tertiary fw-bold py-2 pe-2 ps-1 rounded-end">chat</small>
  </div>
</a>

<!-- Custom JavaScript for Chatbot Push Behavior -->
<script>
  (function () {
    'use strict';

    // -----------------------------
    // Markdown deps loader (local vendor files)
    // -----------------------------
    function vendorPath(relFromVendors) {
      // Robust across:
      // - http(s)://.../pages/*.html  â†’ ../vendors/...
      // - file:///C:/.../pages/*.html â†’ ../vendors/...
      // - http(s)://.../*.html (root) â†’ vendors/...
      // This avoids broken "../" repeats on Windows file:// paths.
      const path = String(window.location.pathname || '').replace(/\\/g, '/');
      const vendorsRel = path.includes('/pages/') ? '../vendors/' : 'vendors/';
      return new URL(vendorsRel + relFromVendors, window.location.href).toString();
    }

    function loadScriptOnce(src) {
      return new Promise((resolve, reject) => {
        try {
          const existing = document.querySelector(`script[src="${src}"]`);
          if (existing) return resolve();
          const scriptEl = document.createElement('script');
          scriptEl.src = src;
          scriptEl.defer = true;
          scriptEl.onload = () => resolve();
          scriptEl.onerror = () => reject(new Error(`Failed to load script: ${src}`));
          document.head.appendChild(scriptEl);
        } catch (e) {
          reject(e);
        }
      });
    }

    // Best-effort: loads deps in background; renderer will fall back to plain text until available.
    function ensureMarkdownDeps() {
      if (window.marked && window.DOMPurify) return Promise.resolve();
      const markedSrc = vendorPath('marked/marked.min.js');
      const purifySrc = vendorPath('dompurify/purify.min.js');
      return loadScriptOnce(markedSrc)
        .then(() => loadScriptOnce(purifySrc))
        .catch((e) => {
          console.warn('Markdown deps load failed:', e);
        });
    }

    // Load Rete.js-style flow renderer (custom, no external deps)
    function ensureReteFlowRenderer() {
      if (window.reteFlowRenderer && window.flowTransforms) return Promise.resolve();

      // Load transformation utilities first
      const transformsSrc = (() => {
        const path = String(window.location.pathname || '').replace(/\\/g, '/');
        const customJsRel = path.includes('/pages/') ? '../custom_js/' : 'custom_js/';
        return new URL(customJsRel + 'flow-transforms.js', window.location.href).toString();
      })();

      // Load renderer
      const rendererSrc = (() => {
        const path = String(window.location.pathname || '').replace(/\\/g, '/');
        const customJsRel = path.includes('/pages/') ? '../custom_js/' : 'custom_js/';
        return new URL(customJsRel + 'rete-flow-renderer.js', window.location.href).toString();
      })();

      return loadScriptOnce(transformsSrc)
        .then(() => loadScriptOnce(rendererSrc))
        .then(() => {
          console.log('[rete-flow] Rete flow renderer initialized');
        })
        .catch((e) => {
          console.warn('Rete flow renderer load failed:', e);
        });
    }

    // (Mermaid removed)

    // Global flag to block heavy layout work during transitions
    let layoutSettling = false;

    function initChatbotPush() {
      const chatbotOffcanvas = document.getElementById('chatbot-offcanvas');
      const viewportElement = document.querySelector('.viewport-scrolls');
      const contentElement = document.querySelector('.content');
      const appRootElement = document.getElementById('app-root');

      if (!chatbotOffcanvas || !appRootElement) return;

      // Hoist the top navbar into its own grid row (so it doesn't shrink/scroll with content)
      // This avoids rewriting the large navbar HTML; we just move the existing DOM node once.
      // Top navbar is now permanently hoisted in side_navbar.html structure.
      // Legacy hoisting logic removed.

      const DEFAULT_CHATBOT_WIDTH = 400;
      const MIN_CHATBOT_WIDTH = 400;
      const MAX_CHATBOT_WIDTH = 1200;

      // Prevent flip-flopping around the default width while dragging.
      // Expand/collapse thresholds create hysteresis (stable UX).
      const EXPAND_AT = 420;
      const COLLAPSE_AT = 380;
      let expandedState = false;

      // Get saved width or use default
      function getChatbotWidth() {
        const saved = localStorage.getItem('chatbotWidth');
        return saved ? parseInt(saved, 10) : DEFAULT_CHATBOT_WIDTH;
      }

      // Save width to localStorage
      function saveChatbotWidth(width) {
        localStorage.setItem('chatbotWidth', width.toString());
      }

      // Update chatbot width and grid column
      function setChatbotWidth(width) {
        width = Math.max(MIN_CHATBOT_WIDTH, Math.min(MAX_CHATBOT_WIDTH, width));
        chatbotOffcanvas.style.width = width + 'px';
        appRootElement.style.setProperty('--chatbot-width', width + 'px');
        // Amount beyond the default 400px. Used to keep content width stable in expanded mode.
        const excess = Math.max(0, width - DEFAULT_CHATBOT_WIDTH);
        appRootElement.style.setProperty('--chatbot-excess', excess + 'px');
        saveChatbotWidth(width);
        updateLayoutBehavior(width);
      }

      // Update layout behavior based on chatbot width
      function updateLayoutBehavior(chatbotWidth) {
        if (!contentElement) return;

        // Update stable expanded state with hysteresis thresholds
        if (!expandedState && chatbotWidth >= EXPAND_AT) {
          expandedState = true;
        } else if (expandedState && chatbotWidth <= COLLAPSE_AT) {
          expandedState = false;
        }

        if (expandedState) {
          // EXPANDED: viewport gets horizontal scroll; content width stays as-if chatbot=400px
          appRootElement.classList.add('chatbot-open', 'chatbot-expanded');
          if (viewportElement) {
            viewportElement.classList.add('chatbot-expanded');
          }
          contentElement.classList.add('chatbot-expanded');
        } else {
          // DEFAULT (â‰¤400px): Grid handles sizing, NO margin needed
          appRootElement.classList.add('chatbot-open');
          appRootElement.classList.remove('chatbot-expanded');
          if (viewportElement) {
            viewportElement.classList.remove('chatbot-expanded');
          }
          // Clear any inline styles (grid handles sizing automatically)
          contentElement.style.minWidth = '';
          contentElement.classList.remove('chatbot-expanded');
        }
      }

      function updateLayoutState(isOpen) {
        if (isOpen) {
          const currentWidth = getChatbotWidth();
          // Initialize stable expanded state based on stored width
          expandedState = currentWidth > DEFAULT_CHATBOT_WIDTH;
          setChatbotWidth(currentWidth); // This will also update layout
        } else {
          expandedState = false;
          appRootElement.classList.remove('chatbot-open', 'chatbot-expanded');
          appRootElement.style.setProperty('--chatbot-width', '0px');
          appRootElement.style.setProperty('--chatbot-excess', '0px');
          if (viewportElement) {
            viewportElement.classList.remove('chatbot-expanded');
          }
          if (contentElement) {
            contentElement.classList.remove('chatbot-expanded');
            contentElement.style.minWidth = '';
          }
        }
      }

      // Initialize resize functionality
      function initChatbotResize() {
        const resizeHandle = document.getElementById('chatbot-resize-handle');
        if (!resizeHandle || !chatbotOffcanvas) return;

        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        function getIsRTL() {
          return document.documentElement.getAttribute('dir') === 'rtl';
        }

        resizeHandle.addEventListener('mousedown', function (e) {
          if (!chatbotOffcanvas.classList.contains('show')) return;

          isResizing = true;
          startX = e.clientX;
          startWidth = parseInt(window.getComputedStyle(chatbotOffcanvas).width, 10);

          document.body.classList.add('chatbot-resizing');
          document.body.style.cursor = 'col-resize';
          document.body.style.userSelect = 'none';

          e.preventDefault();
          e.stopPropagation();
        });

        document.addEventListener('mousemove', function (e) {
          if (!isResizing) return;

          const isRTL = getIsRTL();
          // For right-side offcanvas (offcanvas-end):
          // - Dragging LEFT (negative deltaX) should INCREASE width (handle moves left, chatbot expands)
          // - Dragging RIGHT (positive deltaX) should DECREASE width (handle moves right, chatbot shrinks)
          // So we need to INVERT the deltaX
          let deltaX = isRTL ? (e.clientX - startX) : (startX - e.clientX);

          // Raw calculated width based on cursor position
          let rawWidth = startWidth + deltaX;

          // 1. SNAP CLOSE LOGIC:
          // If cursor moves significantly past the minimum width (e.g. < 250px), close the panel.
          // This gives a "resistance" feel before closing.
          const CLOSE_THRESHOLD = 250;

          if (rawWidth < CLOSE_THRESHOLD) {
            isResizing = false;
            document.body.classList.remove('chatbot-resizing');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            const bsOffcanvas = bootstrap.Offcanvas.getInstance(chatbotOffcanvas);
            if (bsOffcanvas) bsOffcanvas.hide();
            return;
          }

          // 2. VISUAL CLAMP LOCAL:
          // If width is between CLOSE_THRESHOLD (250) and MIN_CHATBOT_WIDTH (400),
          // just render it at MIN_CHATBOT_WIDTH (400) to create the "stop" effect.
          if (rawWidth < MIN_CHATBOT_WIDTH) {
            rawWidth = MIN_CHATBOT_WIDTH;
          }

          // 3. Normal resize (clamped to max)
          setChatbotWidth(rawWidth);

          e.preventDefault();
        });

        document.addEventListener('mouseup', function () {
          if (isResizing) {
            isResizing = false;
            document.body.classList.remove('chatbot-resizing');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            // ðŸ”’ Block chart resize temporarily during CSS transition
            // ECharts will permanently break if resize() is called with invalid dimensions (0Ã—0 or 1-5px)
            layoutSettling = true;

            // Wait for CSS grid + transitions to fully settle (3 RAF frames = ~50ms at 60fps)
            // This ensures container has stable, valid dimensions before any ResizeObserver fires
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  layoutSettling = false;

                  // ðŸ”¥ NOW it is safe to resize charts - dispatch custom event for chart instances
                  document.dispatchEvent(new Event('chatbot:layout-settled'));
                });
              });
            });
          }
        });

        // Prevent text selection while resizing
        resizeHandle.addEventListener('selectstart', function (e) {
          e.preventDefault();
          return false;
        });

        resizeHandle.addEventListener('dragstart', function (e) {
          e.preventDefault();
          return false;
        });
      }

      // Initialize width immediately (before any show events)
      // This ensures the correct width is set even on first open
      const initialWidth = getChatbotWidth();
      chatbotOffcanvas.style.width = initialWidth + 'px';
      appRootElement.style.setProperty('--chatbot-width', initialWidth + 'px');
      const excess = Math.max(0, initialWidth - DEFAULT_CHATBOT_WIDTH);
      appRootElement.style.setProperty('--chatbot-excess', excess + 'px');

      // Handle chatbot show/hide with grid layout
      chatbotOffcanvas.addEventListener('show.bs.offcanvas', function (e) {
        // Set width BEFORE animation starts so it opens with correct width
        const savedWidth = getChatbotWidth();
        setChatbotWidth(savedWidth);
        updateLayoutState(true);
        localStorage.setItem('chatbotOpen', 'true');
      });

      chatbotOffcanvas.addEventListener('shown.bs.offcanvas', function () {
        // Ensure width is still correct after animation
        const savedWidth = getChatbotWidth();
        setChatbotWidth(savedWidth);
        localStorage.setItem('chatbotOpen', 'true');
      });

      // Handle offcanvas hide event
      chatbotOffcanvas.addEventListener('hide.bs.offcanvas', function () {
        updateLayoutState(false);
        localStorage.setItem('chatbotOpen', 'false');
      });

      // Handle offcanvas hidden event (after animation completes)
      chatbotOffcanvas.addEventListener('hidden.bs.offcanvas', function () {
        updateLayoutState(false);
        localStorage.setItem('chatbotOpen', 'false');
      });

      // Also handle when offcanvas is already shown on page load
      if (chatbotOffcanvas.classList.contains('show')) {
        const savedWidth = getChatbotWidth();
        chatbotOffcanvas.style.width = savedWidth + 'px';
        updateLayoutBehavior(savedWidth);
        updateLayoutState(true);
      }

      // Initialize resize functionality
      initChatbotResize();
    }

    function initChatbotComposer() {
      const textarea = document.getElementById('chatbot-input');
      const sendBtn = document.querySelector('#chatbot-offcanvas .send-btn');
      if (!textarea) return;

      function autosize() {
        // Reset then grow to fit content (up to max-height via CSS)
        textarea.style.height = 'auto';
        const cs = window.getComputedStyle(textarea);
        const lh = parseFloat(cs.lineHeight);
        const lineHeight = Number.isFinite(lh) ? lh : 16;
        const pt = parseFloat(cs.paddingTop) || 0;
        const pb = parseFloat(cs.paddingBottom) || 0;
        const max = (lineHeight * 4) + pt + pb; // 4 lines max
        const next = Math.min(textarea.scrollHeight, max);
        textarea.style.height = next + 'px';
      }

      // Toggle button state between voice assistant and send
      function updateButtonState() {
        if (!sendBtn) return;
        const hasText = textarea.value.trim().length > 0;
        const voiceIcon = sendBtn.querySelector('.voice-icon');
        const sendIcon = sendBtn.querySelector('.send-icon');

        if (hasText) {
          // Show send button
          sendBtn.classList.remove('voice-assistant-state');
          sendBtn.setAttribute('aria-label', 'Send Message');
          sendBtn.setAttribute('title', 'Send');
          if (voiceIcon) voiceIcon.style.display = 'none';
          if (sendIcon) sendIcon.style.display = 'flex';
        } else {
          // Show voice assistant button
          sendBtn.classList.add('voice-assistant-state');
          sendBtn.setAttribute('aria-label', 'Voice Assistant');
          sendBtn.setAttribute('title', 'Voice Assistant');
          if (voiceIcon) voiceIcon.style.display = 'flex';
          if (sendIcon) sendIcon.style.display = 'none';
        }
      }

      textarea.addEventListener('input', function () {
        autosize();
        updateButtonState();
      });
      autosize();
      updateButtonState(); // Initial state

      // Enter = send, Shift+Enter = newline
      textarea.addEventListener('keydown', function (e) {
        if (e.key !== 'Enter') return;
        if (e.shiftKey) return; // allow newline

        e.preventDefault();
        // Only send if there's text
        if (textarea.value.trim().length > 0 && sendBtn) {
          sendBtn.click();
        }
      });
    }

    function initChatbotTabs() {
      const chatbotOffcanvas = document.getElementById('chatbot-offcanvas');
      const tabsEl = document.getElementById('chatbot-tabs');
      const newTabBtn = document.getElementById('chatbot-new-tab');
      const messagesEl = chatbotOffcanvas?.querySelector?.('.chat-messages');
      const textarea = document.getElementById('chatbot-input');
      const sendBtn = chatbotOffcanvas?.querySelector?.('.send-btn');
      const modeLabel = document.getElementById('chatbot-mode-label');
      const voiceBtn = document.getElementById('chatbot-voice-btn');

      if (!chatbotOffcanvas || !tabsEl || !messagesEl) return;

      // Kick off markdown deps load early (non-blocking)
      ensureMarkdownDeps();
      // Rete flow renderer loaded on-demand when diagrams are present
      ensureReteFlowRenderer();

      // Treat current markup as the "blank chat" template for new tabs
      const initialTemplate = messagesEl.innerHTML;

      const MODES = /** @type {const} */ (['general', 'agent']);

      let tabCounter = 0;
      /** @type {{sessionId: string|null, html: string, started: boolean} } */
      const emptyModeState = () => ({ sessionId: null, html: initialTemplate, started: false });

      /** @type {{id: string, title: string, mode: Record<string, {sessionId: string|null, html: string}>}[]} */
      const tabs = [];
      let activeId = null;

      function escapeHtml(s) {
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;');
      }

      function getActive() {
        return tabs.find(t => t.id === activeId) || null;
      }

      function getMode() {
        const m = chatbotOffcanvas.dataset.chatbotMode;
        return m === 'agent' ? 'agent' : 'general';
      }

      function setMode(nextMode) {
        const mode = nextMode === 'agent' ? 'agent' : 'general';
        const prev = getMode();
        const active = getActive();
        if (!active) {
          chatbotOffcanvas.dataset.chatbotMode = mode;
          if (modeLabel) modeLabel.textContent = mode === 'agent' ? 'Agent' : 'General';
          return;
        }

        // Save current mode view before switching
        active.mode[prev].html = messagesEl.innerHTML;

        chatbotOffcanvas.dataset.chatbotMode = mode;
        if (modeLabel) modeLabel.textContent = mode === 'agent' ? 'Agent' : 'General';

        // Load new mode view for this tab
        messagesEl.innerHTML = active.mode[mode].html || initialTemplate;
      }

      function saveActiveHtml() {
        const active = getActive();
        if (!active) return;
        const mode = getMode();
        active.mode[mode].html = messagesEl.innerHTML;
      }

      function renderTabs() {
        tabsEl.innerHTML = tabs
          .map(t => {
            const isActive = t.id === activeId;
            return `
              <li class="nav-item" role="presentation" data-chatbot-tab="${t.id}">
                <button class="nav-link ${isActive ? 'active' : ''} pe-2"
                        type="button"
                        role="tab"
                        aria-selected="${isActive ? 'true' : 'false'}"
                        data-chatbot-tab-btn="${t.id}">
                  <span class="text-truncate d-inline-block chatbot-tab-name">${escapeHtml(t.title)}</span>
                  <span class="chatbot-tab-close ms-2 text-body-tertiary"
                        role="button"
                        tabindex="0"
                        aria-label="Close tab"
                        data-chatbot-tab-close="${t.id}">
                    <span class="fas fa-times"></span>
                  </span>
                </button>
              </li>
            `;
          })
          .join('');
      }

      function showTab(id) {
        const target = tabs.find(t => t.id === id);
        if (!target) return;
        saveActiveHtml();
        activeId = id;
        const mode = getMode();
        messagesEl.innerHTML = target.mode[mode].html || initialTemplate;
        renderTabs();
      }

      function createTab(title) {
        saveActiveHtml();
        tabCounter += 1;
        const id = `chat_tab_${Date.now()}_${tabCounter}`;
        tabs.push({
          id,
          title: title || `New chat ${tabCounter}`,
          mode: {
            general: emptyModeState(),
            agent: emptyModeState()
          }
        });
        activeId = id;
        renderTabs();
        messagesEl.innerHTML = initialTemplate;
      }

      function closeTab(id) {
        if (tabs.length <= 1) {
          // Always keep at least one tab
          const only = tabs[0];
          only.title = 'New chat 1';
          only.mode.general = emptyModeState();
          only.mode.agent = emptyModeState();
          activeId = only.id;
          messagesEl.innerHTML = initialTemplate;
          renderTabs();
          return;
        }

        const idx = tabs.findIndex(t => t.id === id);
        if (idx === -1) return;

        const wasActive = activeId === id;
        tabs.splice(idx, 1);

        if (!wasActive) {
          renderTabs();
          return;
        }

        const next = tabs[Math.max(0, idx - 1)];
        activeId = next.id;
        const mode = getMode();
        messagesEl.innerHTML = next.mode[mode].html || initialTemplate;
        renderTabs();
      }

      function appendUserBubble(text) {
        const trimmed = (text || '').trim();
        if (!trimmed) return false;
        messagesEl.insertAdjacentHTML(
          'beforeend',
          `
            <div class="d-flex justify-content-end mt-3">
              <div class="user-message-wrapper d-flex flex-column align-items-end">
                <div class="user-message fs-9 text-body-emphasis">
                  ${escapeHtml(trimmed)}
                </div>
                <div class="user-message-actions">
                  <button type="button" title="Edit" onclick="console.log('Edit clicked')">
                    <span class="far fa-edit"></span>
                  </button>
                  <button type="button" title="Copy" onclick="navigator.clipboard.writeText(this.closest('.user-message-wrapper').querySelector('.user-message').textContent.trim()).then(() => console.log('Copied'))">
                    <span class="far fa-copy"></span>
                  </button>
                </div>
              </div>
            </div>
          `
        );
        return true;
      }

      async function renderFlowDiagram(pendingId, flowDiagramData) {
        try {
          // Validate flow data
          if (!window.flowTransforms || !window.flowTransforms.isValid(flowDiagramData)) {
            console.warn('[chatbot] Invalid flow diagram data');
            return;
          }

          // Find the pending message wrapper using the correct attribute
          const pendingNode = messagesEl.querySelector(`[data-chatbot-pending="${pendingId}"]`);
          if (!pendingNode) {
            console.warn('[chatbot] Pending node not found for pendingId:', pendingId);
            return;
          }

          // Always append INSIDE the assistant bubble (not as a sibling in the flex row)
          const bubble = pendingNode.querySelector?.('div');
          if (!bubble) {
            console.warn('[chatbot] Bubble not found in pending node:', pendingId);
            return;
          }

          // Create a unique container ID for this diagram
          const diagramId = `flow-diagram-${pendingId}`;

          // Check if container already exists (avoid duplicates)
          if (document.getElementById(diagramId)) {
            console.warn('[chatbot] Flow diagram already rendered for:', pendingId);
            return;
          }

          // Create diagram container and insert UNDER the bubble content
          const container = document.createElement('div');
          container.id = diagramId;
          container.className = 'flow-diagram-container mt-3';
          container.style.width = '100%';
          bubble.appendChild(container);

          // Ensure Rete renderer is loaded
          await ensureReteFlowRenderer();

          if (!window.reteFlowRenderer) {
            throw new Error('Rete flow renderer not available');
          }

          // Transform generic data to Rete format
          const reteData = window.flowTransforms.toRete(flowDiagramData);

          // Render the diagram
          await window.reteFlowRenderer.render(diagramId, reteData, {
            readonly: true,
            autoLayout: true,
            layoutDirection: 'horizontal-wrap',
            // spacing.x/y are treated as GAPs between nodes (not absolute step)
            nodeSpacing: { x: 28, y: 54 },
            wrapColumns: 3,
            enablePanZoom: true,
            fitOnInit: true,
            minScale: 0.5,
            maxScale: 2.2,
            animate: true
          });

          console.log('[chatbot] Flow diagram rendered successfully:', diagramId);
        } catch (error) {
          console.error('[chatbot] Failed to render flow diagram:', error);
          // Don't show error to user, just log it
        }
      }

      function appendAssistantPending() {
        const id = `pending_${Date.now()}_${Math.random().toString(16).slice(2)}`;
        messagesEl.insertAdjacentHTML(
          'beforeend',
          `
            <div class="d-flex flex-column align-items-start mt-3" data-chatbot-pending="${id}">
              <div class="ai-message-transparent fs-9 text-body-emphasis markdown-content">
                ...
              </div>
            </div>
          `
        );
        return id;
      }

      // ECharts rendering removed. Mermaid will render diagrams on DONE only.

      function replaceAssistantPending(pendingId, text, isError = false) {
        const node = messagesEl.querySelector?.(`[data-chatbot-pending="${pendingId}"]`);
        if (!node) return;
        const bubble = node.querySelector?.('div');
        if (!bubble) return;
        const msg = text || '';

        if (isError) {
          bubble.textContent = msg;
          bubble.classList.remove('bg-body-secondary');
          bubble.classList.add('bg-danger', 'text-white');
          return;
        }

        // Ensure styling hook exists for markdown CSS
        bubble.classList.add('markdown-content');

        // ChatGPT-style flow blocks: extract completed ```flow ... ``` blocks on DONE only.
        // Replace each extracted block with a stable placeholder <div> at the same position.
        function extractMermaidBlocks(markdownText) {
          // Mermaid support removed; keep text unchanged.
          const src = String(markdownText || '');
          return { markdown: src, diagrams: [] };
          // (legacy Mermaid extraction code removed)
          const diagrams = [];

          const safePendingId = String(pendingId || '').replace(/[^a-zA-Z0-9_-]/g, '_');
          let out = '';
          let i = 0;
          let n = 0;

          while (true) {
            const start = src.indexOf('```mermaid', i);
            if (start === -1) break;

            out += src.slice(i, start);

            const lineEnd = src.indexOf('\n', start);
            if (lineEnd === -1) {
              // Incomplete fence line; keep as-is
              out += src.slice(start);
              i = src.length;
              break;
            }

            // Find a closing fence that starts a line.
            let close = src.indexOf('\n```', lineEnd + 1);
            while (close !== -1) {
              const after = close + 4; // "\n```" length
              if (after >= src.length) break;
              const ch = src[after];
              if (ch === '\n') break;
              if (ch === '\r' && src[after + 1] === '\n') break;
              // Not a real closing fence; keep searching
              close = src.indexOf('\n```', close + 1);
            }

            if (close === -1) {
              // Incomplete flow block; keep as-is (we only extract completed blocks on done)
              out += src.slice(start);
              i = src.length;
              break;
            }

            const payloadText = src.slice(lineEnd + 1, close).trim();

            // Advance i past the closing fence line
            let nextIdx = close + 4;
            if (src[nextIdx] === '\r' && src[nextIdx + 1] === '\n') nextIdx += 2;
            else if (src[nextIdx] === '\n') nextIdx += 1;

            const containerId = `mermaid-${safePendingId}-${n++}`;
            diagrams.push({ containerId, mermaidText: payloadText });

            // Insert Mermaid container (frontend-only HTML injection, backend stays text-only).
            // Mermaid will replace this div contents after DONE.
            const safeText = escapeHtml(payloadText);
            const safeB64 = (() => {
              try { return btoa(unescape(encodeURIComponent(payloadText))); } catch (_) { return ''; }
            })();
            out +=
              '\n\n' +
              `<div id="${containerId}" class="mermaid flow-diagram-placeholder" data-mermaid-src-b64="${safeB64}" ` +
              `style="width: 100%; min-height: 360px; margin-top: 1rem; margin-bottom: 1rem; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 0.5rem; padding: 0.5rem;">` +
              `${safeText}` +
              `</div>` +
              '\n\n';

            i = nextIdx;
          }

          out += src.slice(i);
          return { markdown: out, diagrams };
        }

        const extracted = extractMermaidBlocks(msg);
        const msgWithoutFlow = extracted.markdown;
        const mermaidDiagrams = [];

        // n8n-style preview animation (UI-only)
        function startMermaidPreviewAnimationForBubble(bubbleEl) {
          try {
            const debugMermaid = (() => {
              try { return localStorage.getItem('chatbot_mermaid_debug') === 'true'; } catch (_) { return false; }
            })();
            const dbg = (...args) => { if (debugMermaid) console.log('[mermaid-preview]', ...args); };

            const mermaidDivs = Array.from(bubbleEl.querySelectorAll?.('.mermaid') || []);
            if (!mermaidDivs.length) {
              dbg('no .mermaid divs in bubble');
              return;
            }

            // If Mermaid hasn't inserted SVG yet, retry shortly (don't mark started).
            const hasAnySvg = mermaidDivs.some(d => d.querySelector('svg'));
            if (!hasAnySvg) {
              dbg('svg not present yet; scheduling retry');
              if (!bubbleEl._mermaidPreviewRetryTimer) {
                bubbleEl._mermaidPreviewRetryTimer = setTimeout(() => {
                  bubbleEl._mermaidPreviewRetryTimer = null;
                  startMermaidPreviewAnimationForBubble(bubbleEl);
                }, 120);
              }
              return;
            }

            // Start once per rendered message bubble (after SVG exists)
            if (bubbleEl._mermaidPreviewStarted) {
              dbg('already started; skipping');
              return;
            }
            bubbleEl._mermaidPreviewStarted = true;

            bubbleEl.classList.add('mermaid-preview-running');
            // Also tag the diagram containers for selector robustness
            mermaidDivs.forEach(d => d.classList.add('mermaid-preview-running'));
            dbg('started; mermaidDivs=', mermaidDivs.length);

            // Parse an ordered list of node IDs from mermaid source (first diagram only).
            // This is a preview loop; it does not represent real execution.
            function decodeMermaidSrc(div) {
              const b64 = div?.dataset?.mermaidSrcB64 || '';
              if (!b64) return (div?.textContent || '');
              try { return decodeURIComponent(escape(atob(b64))); } catch (_) { return (div?.textContent || ''); }
            }

            function parseMermaidGraph(src) {
              const srcNorm = String(src || '').replace(/\r\n/g, '\n');
              const lines = srcNorm.split('\n').map(l => l.trim()).filter(Boolean);
              const nodeOrder = [];
              const seen = new Set();
              const edges = []; // {src, dst}

              // Use RegExp(...) to avoid HTML/JS parser edge cases in some editors
              const edgeRe = new RegExp('^([A-Za-z0-9_]+)\\\\s*(?:--\\\\s*\".*?\"\\\\s*)?-->\\\\s*([A-Za-z0-9_]+)');
              const edgeRe2 = new RegExp('^([A-Za-z0-9_]+)\\\\s*-->\\\\s*([A-Za-z0-9_]+)');
              const nodeRe = new RegExp('^([A-Za-z0-9_]+)\\\\s*(?:\\\\[\\\\s*\".*?\"\\\\s*\\\\]|\\\\{\\\\s*\".*?\"\\\\s*\\\\})');

              for (const line of lines) {
                let m = line.match(edgeRe) || line.match(edgeRe2);
                if (m) {
                  const a = m[1], b = m[2];
                  edges.push({ src: a, dst: b });
                  if (!seen.has(a)) { seen.add(a); nodeOrder.push(a); }
                  if (!seen.has(b)) { seen.add(b); nodeOrder.push(b); }
                  continue;
                }
                m = line.match(nodeRe);
                if (m) {
                  const a = m[1];
                  if (!seen.has(a)) { seen.add(a); nodeOrder.push(a); }
                }
              }

              // Fallback to any ids found
              return { nodeOrder, edges };
            }

            // Build one combined preview loop per bubble (across all diagrams)
            const diagrams = mermaidDivs
              .map(div => {
                const src = decodeMermaidSrc(div);
                const parsed = parseMermaidGraph(src);
                return { div, ...parsed };
              })
              .filter(d => d.nodeOrder.length);

            if (!diagrams.length) {
              dbg('no diagrams with nodeOrder found (parse failed?)');
              return;
            }
            dbg('parsed diagrams=', diagrams.length, 'first nodeOrder len=', diagrams[0]?.nodeOrder?.length, 'edges=', diagrams[0]?.edges?.length);

            function findNodeEl(svg, nodeId) {
              if (!svg || !nodeId) return null;
              const esc = (window.CSS && CSS.escape) ? CSS.escape(nodeId) : nodeId.replace(/[^\w-]/g, '_');
              // Mermaid ids vary by version; match substring.
              return svg.querySelector(`g.node[id*="${esc}"]`) || svg.querySelector(`g.node [id*="${esc}"]`)?.closest?.('g.node') || null;
            }

            function findOutgoingEdgeGroups(svg, nodeId, edges) {
              const esc = (window.CSS && CSS.escape) ? CSS.escape(nodeId) : nodeId.replace(/[^\w-]/g, '_');
              const outgoing = edges.filter(e => e.src === nodeId);
              if (!outgoing.length) return [];
              const groups = [];
              for (const e of outgoing) {
                const dstEsc = (window.CSS && CSS.escape) ? CSS.escape(e.dst) : String(e.dst).replace(/[^\w-]/g, '_');
                // edgePath ids usually include both src and dst; match both.
                const g = svg.querySelector(`g.edgePath[id*="${esc}"][id*="${dstEsc}"]`);
                if (g) groups.push(g);
              }
              return groups;
            }

            // Main loop: highlight next node every 650ms
            const intervalMs = 650;
            let idx = 0;

            function clearActive() {
              for (const d of diagrams) {
                const svg = d.div.querySelector('svg');
                if (!svg) continue;
                svg.querySelectorAll('g.node.preview-node-active').forEach(el => el.classList.remove('preview-node-active'));
                svg.querySelectorAll('g.edgePath.preview-edge-active').forEach(el => el.classList.remove('preview-edge-active'));
              }
            }

            function step() {
              clearActive();
              for (const d of diagrams) {
                const svg = d.div.querySelector('svg');
                if (!svg) continue;
                const nodeId = d.nodeOrder[idx % d.nodeOrder.length];
                const nodeEl = findNodeEl(svg, nodeId);
                if (nodeEl) nodeEl.classList.add('preview-node-active');
                const outEdges = findOutgoingEdgeGroups(svg, nodeId, d.edges);
                outEdges.forEach(g => g.classList.add('preview-edge-active'));
              }
              idx += 1;
            }

            // Start only after at least one svg exists
            const hasSvg = diagrams.some(d => d.div.querySelector('svg'));
            if (!hasSvg) return;

            step();
            bubbleEl._mermaidPreviewTimer = setInterval(step, intervalMs);
            dbg('interval started every', intervalMs, 'ms');
          } catch (_) {
            // ignore preview failures
          }
        }

        // Render markdown if deps available; else fall back to plain text
        try {
          if (window.marked && window.DOMPurify) {
            // Allow div (placeholders). Do NOT allow script.
            const allowedTags = [
              'p', 'br', 'strong', 'em', 'u', 's',
              'code', 'pre',
              'ul', 'ol', 'li',
              'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
              'blockquote', 'a', 'hr',
              'table', 'thead', 'tbody', 'tr', 'th', 'td',
              'div'
            ];

            // Parse markdown (marked.js preserves HTML tags by default)
            let rawHtml;
            try {
              if (window.marked && typeof window.marked.parse === 'function') {
                // Try with options if supported (newer versions)
                if (window.marked.setOptions) {
                  rawHtml = window.marked.parse(msgWithoutFlow);
                } else {
                  rawHtml = window.marked.parse(msgWithoutFlow);
                }
              } else {
                rawHtml = msgWithoutFlow; // Fallback to raw text
              }
            } catch (e) {
              console.warn('Markdown parsing failed:', e);
              rawHtml = msgWithoutFlow;
            }
            const cleanHtml = window.DOMPurify.sanitize(rawHtml, {
              ALLOWED_TAGS: allowedTags,
              ALLOWED_ATTR: ['href', 'title', 'target', 'rel', 'id', 'style', 'type', 'class'],
              KEEP_CONTENT: true,  // Preserve content
              ADD_ATTR: ['id', 'style', 'class']  // Ensure these attributes are kept
            });

            // Set the HTML atomically (placeholders already included)
            bubble.innerHTML = cleanHtml;

            // Best-effort: ensure safe link behavior
            bubble.querySelectorAll?.('a[href]')?.forEach(a => {
              a.setAttribute('target', '_blank');
              a.setAttribute('rel', 'noopener noreferrer');
            });

            // Add action buttons after the message content
            const actionsHtml = `
              <div class="ai-message-actions">
                <button type="button" title="Like" onclick="console.log('Like clicked')">
                  <span class="far fa-thumbs-up"></span>
                </button>
                <button type="button" title="Dislike" onclick="console.log('Dislike clicked')">
                  <span class="far fa-thumbs-down"></span>
                </button>
                <button type="button" title="Copy" onclick="navigator.clipboard.writeText(this.closest('.d-flex').querySelector('.ai-message-transparent').textContent.trim()).then(() => console.log('Copied'))">
                  <span class="far fa-copy"></span>
                </button>
              </div>
            `;

            // Insert action buttons after the message content
            node.insertAdjacentHTML('beforeend', actionsHtml);

            // Mermaid rendering removed.
          } else {
            bubble.textContent = msg;
          }
        } catch (e) {
          console.warn('Markdown render failed:', e);
          bubble.textContent = msg;
        }
      }

      // -----------------------------
      // Streaming Markdown Rendering (ChatGPT-style)
      // -----------------------------
      function safeMarkdownForStreaming(text) {
        let t = String(text || '');

        // Diagrams: treat ```flow blocks as unstable during streaming.
        // Do NOT render diagrams; replace with a stable placeholder and never initialize ECharts here.
        (function suppressMermaidBlocks() {
          const placeholder =
            '\n\n' +
            '<div class="flow-diagram-placeholder" ' +
            'style="width:100%;height:360px;margin-top:1rem;margin-bottom:1rem;' +
            'background:#f8f9fa;border:1px solid #dee2e6;border-radius:0.5rem;' +
            'display:flex;align-items:center;justify-content:center;color:#6c757d;font-size:0.95rem;">' +
            'Rendering diagramâ€¦' +
            '</div>\n\n';

          let src = t;
          let out = '';
          let i = 0;
          while (true) {
            const start = src.indexOf('```mermaid', i);
            if (start === -1) break;

            out += src.slice(i, start);

            const lineEnd = src.indexOf('\n', start);
            if (lineEnd === -1) {
              // Incomplete fence start; replace tail with placeholder
              out += placeholder;
              i = src.length;
              break;
            }

            // Find closing fence line (starts a line).
            let close = src.indexOf('\n```', lineEnd + 1);
            while (close !== -1) {
              const after = close + 4;
              if (after >= src.length) break;
              const ch = src[after];
              if (ch === '\n') break;
              if (ch === '\r' && src[after + 1] === '\n') break;
              close = src.indexOf('\n```', close + 1);
            }

            if (close === -1) {
              // Incomplete flow block; replace tail with placeholder
              out += placeholder;
              i = src.length;
              break;
            }

            // Skip the entire flow block (closed) and insert placeholder
            out += placeholder;

            // Advance past closing fence line
            i = close + 4;
            if (src[i] === '\r' && src[i + 1] === '\n') i += 2;
            else if (src[i] === '\n') i += 1;
          }

          out += src.slice(i);
          t = out;
        })();

        // Fenced code blocks: don't render until closed.
        // If fence count is odd, break the last fence so it is treated as plain text.
        const fence = '```';
        const fenceCount = (t.match(/```/g) || []).length;
        if (fenceCount % 2 === 1) {
          const last = t.lastIndexOf(fence);
          if (last !== -1) {
            // Insert a zero-width space inside the fence to prevent markdown parsing,
            // while keeping it visually identical to ``` for the user.
            const brokenFence = '``\u200b`';
            t = t.slice(0, last) + brokenFence + t.slice(last + fence.length);
          }
        }

        // Tables: treat as unstable until a blank line appears after the last row.
        // We suppress a trailing (still-growing) table by escaping pipes in the trailing table region.
        try {
          const lines = t.split('\n');
          const sepRe = /^\s*\|?\s*:?-+:?\s*(\|\s*:?-+:?\s*)+\|?\s*$/; // markdown table separator
          const rowRe = /^\s*\|.*\|\s*$/; // simple row heuristic
          let sepLineIdx = -1;
          for (let i = lines.length - 1; i >= 0; i--) {
            if (sepRe.test(lines[i] || '')) { sepLineIdx = i; break; }
          }
          if (sepLineIdx !== -1) {
            // Find table start: walk upward from header/separator through contiguous table-like lines
            let tableStart = Math.max(0, sepLineIdx - 1);
            while (tableStart > 0) {
              const prev = lines[tableStart - 1] || '';
              if (prev.trim() === '') break;
              // allow header rows, separator, and pipe rows
              if (rowRe.test(prev) || sepRe.test(prev)) {
                tableStart -= 1;
                continue;
              }
              break;
            }

            // Find table end: walk downward through contiguous table-like lines
            let tableEnd = sepLineIdx;
            while (tableEnd + 1 < lines.length) {
              const nxt = lines[tableEnd + 1] || '';
              if (nxt.trim() === '') break;
              if (rowRe.test(nxt) || sepRe.test(nxt)) {
                tableEnd += 1;
                continue;
              }
              break;
            }

            const terminatorLine = lines[tableEnd + 1] || '';
            const hasTerminator = (terminatorLine.trim() === '') || (!!terminatorLine && !(rowRe.test(terminatorLine) || sepRe.test(terminatorLine)));

            // If the table touches the end of the current streamed text and has no terminator yet,
            // keep it as plain text to avoid half-rendered tables.
            if (!hasTerminator && tableEnd >= lines.length - 1) {
              for (let j = tableStart; j < lines.length; j++) {
                lines[j] = (lines[j] || '').replaceAll('|', '&#124;');
              }
              t = lines.join('\n');
            }
          }
        } catch (_) { }

        return t;
      }

      function updateAssistantPendingText(pendingId, text) {
        const node = messagesEl.querySelector?.(`[data-chatbot-pending="${pendingId}"]`);
        if (!node) return;
        const bubble = node.querySelector?.('div');
        if (!bubble) return;

        // Store latest accumulated text and batch DOM updates
        bubble._streamAccumulatedText = String(text || '');
        if (bubble._streamRaf) return;

        bubble._streamRaf = requestAnimationFrame(() => {
          bubble._streamRaf = null;

          const msg = bubble._streamAccumulatedText || '';
          const safe = safeMarkdownForStreaming(msg);
          if (safe === bubble._lastStreamSafeText) return;
          bubble._lastStreamSafeText = safe;

          // Keep it in normal (non-error) style while streaming
          bubble.classList.remove('bg-danger', 'text-white');
          bubble.classList.add('bg-body-secondary');
          bubble.classList.add('markdown-content');

          try {
            if (window.marked && window.DOMPurify && typeof window.marked.parse === 'function') {
              // Stable-only tags during streaming (no script; diagrams are placeholders only)
              const allowedTags = [
                'p', 'br', 'strong', 'em', 'u', 's',
                'code',
                'ul', 'ol', 'li',
                'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                'blockquote', 'a', 'hr',
                'div'
              ];

              let rawHtml = '';
              try {
                rawHtml = window.marked.parse(safe);
              } catch (_) {
                rawHtml = escapeHtml(safe).replace(/\n/g, '<br>');
              }

              const cleanHtml = window.DOMPurify.sanitize(rawHtml, {
                ALLOWED_TAGS: allowedTags,
                ALLOWED_ATTR: ['href', 'title', 'target', 'rel', 'class', 'style'],
                KEEP_CONTENT: true
              });

              bubble.innerHTML = cleanHtml;

              // Safe link behavior
              bubble.querySelectorAll?.('a[href]')?.forEach(a => {
                a.setAttribute('target', '_blank');
                a.setAttribute('rel', 'noopener noreferrer');
              });
            } else {
              // Deps not ready: still avoid raw token phase; render as escaped HTML with <br>
              bubble.innerHTML = escapeHtml(safe).replace(/\n/g, '<br>');
            }
          } catch (_) {
            bubble.innerHTML = escapeHtml(safe).replace(/\n/g, '<br>');
          }
        });
      }

      // NOTE: Do NOT auto-detect camera_id from UI context.
      // The agent will ask the user which camera they want, then store it in agent_state.
      // UI only uses camera_id returned by backend in ChatMessageResponse.

      function getAssistantBubbleEl(pendingId) {
        const node = messagesEl.querySelector?.(`[data-chatbot-pending="${pendingId}"]`);
        const bubble = node?.querySelector?.('div');
        return { node, bubble };
      }

      async function openZoneEditorInBubble(pendingId, cameraId) {
        const { bubble } = getAssistantBubbleEl(pendingId);
        if (!bubble) return;

        // Avoid duplicating editor for same message
        const existing = bubble.querySelector?.(`[data-zone-editor="${pendingId}"]`);
        if (existing) return;

        const host = document.createElement('div');
        host.className = 'zone-editor';
        host.setAttribute('data-zone-editor', pendingId);
        host.innerHTML = `
          <div class="zone-editor__header">
            <div class="zone-editor__title">Draw monitoring zone</div>
            <div class="text-body-tertiary fs-10">Camera: <span class="font-monospace">${escapeHtml(cameraId || 'â€”')}</span></div>
          </div>
          <div class="zone-editor__body">
            <div class="text-body-tertiary fs-9" data-zone-status>Loading snapshotâ€¦</div>
          </div>
        `;
        bubble.appendChild(host);

        const statusEl = host.querySelector('[data-zone-status]');
        const bodyEl = host.querySelector('.zone-editor__body');

        if (!cameraId) {
          if (statusEl) statusEl.textContent = 'Camera is not selected yet. Please provide a camera first.';
          return;
        }

        let blob = null;
        try {
          blob = await window.visionAPI.getCameraSnapshot(cameraId);
        } catch (e) {
          if (statusEl) statusEl.textContent = e?.message ? String(e.message) : 'Failed to load snapshot.';
          return;
        }

        const url = URL.createObjectURL(blob);

        // Editor UI
        bodyEl.innerHTML = `
          <div class="zone-editor__canvas-wrap">
            <img class="zone-editor__img" alt="Camera snapshot" />
            <canvas class="zone-editor__canvas"></canvas>
          </div>
          <div class="zone-editor__hint">Click to add polygon points. Use â€œUndoâ€ to remove last point. Save needs at least 3 points.</div>
          <div class="zone-editor__actions">
            <button type="button" class="btn btn-sm btn-outline-secondary" data-zone-undo>Undo</button>
            <button type="button" class="btn btn-sm btn-outline-secondary" data-zone-clear>Clear</button>
            <button type="button" class="btn btn-sm btn-primary" data-zone-save>Save zone</button>
          </div>
        `;

        const imgEl = bodyEl.querySelector('.zone-editor__img');
        const canvasEl = bodyEl.querySelector('.zone-editor__canvas');
        const btnUndo = bodyEl.querySelector('[data-zone-undo]');
        const btnClear = bodyEl.querySelector('[data-zone-clear]');
        const btnSave = bodyEl.querySelector('[data-zone-save]');

        /** @type {{x:number,y:number}[]} */
        const points = [];

        function resizeCanvasToImage() {
          if (!imgEl || !canvasEl) return;
          // Wait for image to have natural dimensions
          if (!imgEl.naturalWidth || !imgEl.naturalHeight) return;
          const rect = imgEl.getBoundingClientRect();
          const w = Math.max(1, Math.round(rect.width));
          const h = Math.max(1, Math.round(rect.height));
          if (w <= 0 || h <= 0) return; // Skip if container not laid out yet
          if (canvasEl.width !== w) canvasEl.width = w;
          if (canvasEl.height !== h) canvasEl.height = h;
          // Force a redraw after resize
          draw();
        }

        function draw() {
          if (!canvasEl) return;
          const ctx = canvasEl.getContext('2d');
          if (!ctx) return;
          ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

          // Polygon fill
          if (points.length >= 2) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.closePath();
            ctx.fillStyle = 'rgba(42, 123, 228, 0.20)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(42, 123, 228, 0.95)';
            ctx.lineWidth = 2;
            ctx.stroke();
          }

          // Points
          ctx.fillStyle = 'rgba(42, 123, 228, 1)';
          for (const p of points) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        function getClickPoint(ev) {
          const rect = canvasEl.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          return { x: Math.max(0, Math.min(rect.width, x)), y: Math.max(0, Math.min(rect.height, y)) };
        }

        function disableEditor(disabled) {
          [btnUndo, btnClear, btnSave].forEach(b => {
            if (!b) return;
            b.disabled = !!disabled;
          });
          if (canvasEl) canvasEl.style.pointerEvents = disabled ? 'none' : 'auto';
        }

        function pointsToImageCoords() {
          const rect = imgEl.getBoundingClientRect();
          const imgW = imgEl.naturalWidth || 0;
          const imgH = imgEl.naturalHeight || 0;
          if (!imgW || !imgH || !rect.width || !rect.height) return null;
          const sx = imgW / rect.width;
          const sy = imgH / rect.height;
          return points.map(p => [Math.round(p.x * sx), Math.round(p.y * sy)]);
        }

        canvasEl.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          if (!canvasEl) return;
          points.push(getClickPoint(ev));
          draw();
        });

        btnUndo?.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          points.pop();
          draw();
        });

        btnClear?.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          points.length = 0;
          draw();
        });

        btnSave?.addEventListener('click', async () => {
          if (points.length < 3) return;
          const coords = pointsToImageCoords();
          if (!coords) return;
          const zoneData = {
            zone: {
              type: 'polygon',
              coordinates: coords,
            },
            image: {
              width: imgEl.naturalWidth || null,
              height: imgEl.naturalHeight || null,
            },
            camera_id: cameraId,
          };

          disableEditor(true);
          try {
            // NOTE: Do NOT pass cameraIdOverride. Agent already has camera_id in state (extracted from user earlier).
            // zone_data contains camera_id as metadata only, not as a separate field to update state.
            await sendTextMessage('Zone selected. Please continue.', { zoneData });
            // Safe cleanup: revoke snapshot URL after zone is submitted.
            // (Revoking on img "load" can cause the image to disappear on some Chromium/Electron repaints.)
            try { URL.revokeObjectURL(url); } catch (_) { }
          } finally {
            // Keep UI disabled; user can draw again only after assistant asks again
          }
        });

        imgEl.addEventListener('load', () => {
          // Use requestAnimationFrame to ensure layout is complete before sizing canvas
          requestAnimationFrame(() => {
            resizeCanvasToImage();
            // Second RAF to catch any delayed layout changes
            requestAnimationFrame(resizeCanvasToImage);
          });
          // NOTE: Do NOT revoke the blob URL here; it can make the image disappear
          // later (e.g., after clicking) in some Chromium/Electron environments.
        }, { once: true });

        imgEl.src = url;
        // Best-effort: keep canvas in sync on window resize
        const resizeHandler = () => requestAnimationFrame(resizeCanvasToImage);
        window.addEventListener('resize', resizeHandler, { passive: true });
        // Initial size attempts (in case image is cached and loads instantly)
        setTimeout(() => requestAnimationFrame(resizeCanvasToImage), 0);
        setTimeout(() => requestAnimationFrame(resizeCanvasToImage), 100);
      }

      async function sendTextMessage(text, options = {}) {
        const trimmed = (text || '').trim();
        if (!trimmed) return;

        if (!window.visionAPI || typeof window.visionAPI.isAuthenticated !== 'function') {
          return;
        }

        const active = getActive();
        if (!active) return;

        const mode = getMode();
        const state = active.mode[mode];

        // On first message per tab+mode, remove the initial welcome/suggestions content
        if (!state.started) {
          state.started = true;
          messagesEl.innerHTML = '';
        }

        const ok = appendUserBubble(trimmed);
        if (!ok) return;
        const pendingId = appendAssistantPending();
        saveActiveHtml();
        // Always keep view pinned to bottom
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
          // ------------------------------------------------------------
          // DEMO MODE (no-backend): useful to debug chart rendering/resizing
          // Commands:
          // - "demo on"  â†’ enable demo mode
          // - "demo off" â†’ disable demo mode
          // - (chart demo removed)
          // ------------------------------------------------------------
          const DEMO_KEY = 'chatbot_demo_mode';
          const lower = trimmed.toLowerCase();

          if (lower === 'demo on' || lower === '/demo on') {
            localStorage.setItem(DEMO_KEY, 'true');
            replaceAssistantPending(pendingId, '**Demo mode enabled** (backend calls are disabled). Type `demo off` to exit.');
            state.html = messagesEl.innerHTML;
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return;
          }
          if (lower === 'demo off' || lower === '/demo off') {
            localStorage.setItem(DEMO_KEY, 'false');
            replaceAssistantPending(pendingId, '**Demo mode disabled** (backend calls are enabled again).');
            state.html = messagesEl.innerHTML;
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return;
          }

          const demoEnabled = localStorage.getItem(DEMO_KEY) === 'true';
          if (demoEnabled) {
            // Demo mode kept for quick backend-off testing; Mermaid demo removed.
            replaceAssistantPending(pendingId, `**Demo mode** is ON. Backend calls are disabled.\n\nYou said: \`${escapeHtml(trimmed)}\``);
            state.html = messagesEl.innerHTML;
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return;
          }

          if (!window.visionAPI.isAuthenticated()) {
            throw new Error('Please login first.');
          }

          // Cancel any in-flight stream for this tab+mode
          try { state._abortController?.abort?.(); } catch (_) { }
          state._abortController = new AbortController();

          let acc = '';
          let finalPayload = null;
          let sawError = false;

          const zoneData = options?.zoneData || null;
          // NOTE: Do NOT send camera_id from UI. Agent asks user, extracts it via LLM tool, stores in agent_state.
          // UI only uses camera_id returned by backend in ChatMessageResponse (for snapshot fetch).
          const stream = (mode === 'agent')
            ? window.visionAPI.chatWithAgentStream(trimmed, state.sessionId, null, zoneData, state._abortController.signal)
            : window.visionAPI.generalChatStream(trimmed, state.sessionId, state._abortController.signal);

          for await (const evt of stream) {
            const evName = evt?.event || 'message';
            const data = evt?.data;

            if (evName === 'meta') {
              const sid = data?.session_id || null;
              if (sid) state.sessionId = sid;
              continue;
            }

            if (evName === 'token') {
              const delta = data?.delta != null ? String(data.delta) : '';
              if (delta) {
                acc += delta;
                // ChatGPT-style micro-batching:
                // Only trigger a render on meaningful boundaries, plus a periodic flush.
                const boundary = /[\s.,!?;:\n]/.test(delta);
                const now = Date.now();
                const last = state._lastStreamUiFlushTs || 0;
                const shouldFlush = boundary || (now - last) > 200;
                if (shouldFlush) {
                  state._lastStreamUiFlushTs = now;

                  // Scroll anchoring: only auto-scroll if user is already near bottom
                  const distanceFromBottom = messagesEl.scrollHeight - (messagesEl.scrollTop + messagesEl.clientHeight);
                  const shouldAutoScroll = distanceFromBottom < 60;

                  updateAssistantPendingText(pendingId, acc);
                  state.html = messagesEl.innerHTML;
                  if (shouldAutoScroll) {
                    messagesEl.scrollTop = messagesEl.scrollHeight;
                  }
                }
              }
              continue;
            }

            if (evName === 'error') {
              sawError = true;
              // keep streaming; final "done" will close out
              continue;
            }

            if (evName === 'done') {
              finalPayload = data;
              break;
            }
          }

          // Ensure we flush any remaining text even if last deltas had no boundaries
          if (acc) {
            updateAssistantPendingText(pendingId, acc);
          }

          const answer = finalPayload?.response ?? acc ?? '';
          const nextSessionId = finalPayload?.session_id ?? null;
          if (nextSessionId) state.sessionId = nextSessionId;

          const isError = (finalPayload?.status === 'error') || sawError;
          replaceAssistantPending(pendingId, answer || '(empty response)', isError);

          // Render flow diagram AFTER replacing so markdown is final
          if (!isError && finalPayload?.flow_diagram_data) {
            await renderFlowDiagram(pendingId, finalPayload.flow_diagram_data);
          }

          // Use camera_id resolved by backend (agent extracted it from user's message and stored in state)
          if (!isError && mode === 'agent') {
            const resolvedCameraId = finalPayload?.camera_id || null;
            if (resolvedCameraId) {
              state.cameraId = resolvedCameraId;
            }

            const needsZoneUi = !!(finalPayload?.awaiting_zone_input || finalPayload?.zone_required);
            if (needsZoneUi) {
              // Only use camera_id from backend response (agent already extracted it from user)
              if (resolvedCameraId) {
                await openZoneEditorInBubble(pendingId, resolvedCameraId);
              } else {
                // Camera not selected yet - agent will ask for it first
                console.log('[zone-editor] Waiting for agent to extract camera_id from user');
              }
            }
          }

          state.html = messagesEl.innerHTML;
          messagesEl.scrollTop = messagesEl.scrollHeight;
        } catch (err) {
          if (err && (err.name === 'AbortError' || String(err).includes('AbortError'))) {
            // Expected when a newer message cancels an in-flight stream
            return;
          }
          const msg = err?.message ? String(err.message) : 'Chat request failed.';
          replaceAssistantPending(pendingId, msg, true);
          state.html = messagesEl.innerHTML;
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }
      }

      // Events
      tabsEl.addEventListener('click', (e) => {
        const closeEl = e.target.closest?.('[data-chatbot-tab-close]');
        if (closeEl) {
          e.stopPropagation();
          const id = closeEl.getAttribute('data-chatbot-tab-close');
          if (id) closeTab(id);
          return;
        }

        const tabBtn = e.target.closest?.('[data-chatbot-tab-btn]');
        if (tabBtn) {
          const id = tabBtn.getAttribute('data-chatbot-tab-btn');
          if (id) showTab(id);
        }
      });

      newTabBtn?.addEventListener('click', () => createTab());

      // Shared voice recording state (used by both send button and voice button if exists)
      let voiceRecorder = null;
      let voiceChunks = [];
      let isVoiceRecording = false;

      // Voice recording functions (shared)
      async function startVoiceRecording() {
        if (!navigator.mediaDevices?.getUserMedia) {
          throw new Error('Microphone not supported.');
        }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        voiceChunks = [];
        voiceRecorder = new MediaRecorder(stream);
        voiceRecorder.ondataavailable = (ev) => {
          if (ev.data && ev.data.size > 0) voiceChunks.push(ev.data);
        };
        voiceRecorder.onstop = () => {
          stream.getTracks().forEach(t => t.stop());
        };
        voiceRecorder.start();
        isVoiceRecording = true;
        // Update button appearance when recording
        if (sendBtn) sendBtn.classList.add('recording');
      }

      async function stopVoiceRecordingAndSend() {
        if (!voiceRecorder) return;
        const active = getActive();
        if (!active) return;
        if (!window.visionAPI?.isAuthenticated?.()) throw new Error('Please login first.');
        if (getMode() !== 'general') throw new Error('Voice is available in General mode only.');

        const state = active.mode.general;

        // On first voice use per tab+general, remove welcome/suggestions
        if (!state.started) {
          state.started = true;
          messagesEl.innerHTML = '';
        }

        const stopped = new Promise(resolve => {
          voiceRecorder.addEventListener('stop', resolve, { once: true });
        });
        voiceRecorder.stop();
        await stopped;

        isVoiceRecording = false;
        if (sendBtn) sendBtn.classList.remove('recording');

        const blob = new Blob(voiceChunks, { type: 'audio/webm' });
        const file = new File([blob], 'voice.webm', { type: 'audio/webm' });

        // Render placeholders
        appendUserBubble('[Voice message]');
        const pendingId = appendAssistantPending();
        saveActiveHtml();
        messagesEl.scrollTop = messagesEl.scrollHeight;

        const result = await window.visionAPI.voiceChat(file, state.sessionId);
        if (result?.sessionId) state.sessionId = result.sessionId;
        const textResp = result?.textResponse || '(voice response)';
        replaceAssistantPending(pendingId, textResp);
        state.html = messagesEl.innerHTML;
        messagesEl.scrollTop = messagesEl.scrollHeight;

        // Play audio (best-effort)
        try {
          if (result?.audioBlob) {
            const url = URL.createObjectURL(result.audioBlob);
            const audio = new Audio(url);
            audio.play().catch(() => { });
            audio.onended = () => URL.revokeObjectURL(url);
          }
        } catch { }
      }

      sendBtn?.addEventListener('click', async () => {
        if (!textarea) return;

        // Check if button is in voice assistant mode (textarea is empty)
        const hasText = textarea.value.trim().length > 0;

        if (!hasText) {
          // Voice assistant mode - handle voice recording
          try {
            if (getMode() !== 'general') {
              // Show message that voice is only available in General mode
              return;
            }

            if (!isVoiceRecording) {
              await startVoiceRecording();
            } else {
              await stopVoiceRecordingAndSend();
            }
          } catch (err) {
            isVoiceRecording = false;
            if (sendBtn) sendBtn.classList.remove('recording');
            const active = getActive();
            if (active) {
              appendAssistantPending();
              const lastPending = messagesEl.querySelector?.('[data-chatbot-pending]');
              if (lastPending) {
                const bubble = lastPending.querySelector?.('div');
                if (bubble) {
                  bubble.textContent = err?.message ? String(err.message) : 'Voice failed.';
                  bubble.classList.remove('bg-body-secondary');
                  bubble.classList.add('bg-danger', 'text-white');
                }
              }
              active.mode.general.html = messagesEl.innerHTML;
              messagesEl.scrollTop = messagesEl.scrollHeight;
            }
          }
        } else {
          // Send mode - send text message
          const text = textarea.value;
          textarea.value = '';
          textarea.dispatchEvent(new Event('input'));
          sendTextMessage(text);
        }
      });

      document.addEventListener('click', (e) => {
        const el = e.target.closest?.('[data-chatbot-action="clear"]');
        if (!el) return;
        e.preventDefault();
        const active = getActive();
        if (!active) return;
        const mode = getMode();
        active.mode[mode] = emptyModeState();
        messagesEl.innerHTML = initialTemplate;
        saveActiveHtml();
      });

      document.addEventListener('click', (e) => {
        const el = e.target.closest?.('[data-chatbot-mode]');
        if (!el) return;
        e.preventDefault();
        const mode = el.getAttribute('data-chatbot-mode');
        if (!mode) return;
        setMode(mode);
      });

      // Voice (General only): click to start/stop recording
      (function initVoice() {
        if (!voiceBtn) return;
        let recorder = null;
        let chunks = [];
        let isRecording = false;

        async function start() {
          if (!navigator.mediaDevices?.getUserMedia) {
            throw new Error('Microphone not supported.');
          }
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          chunks = [];
          recorder = new MediaRecorder(stream);
          recorder.ondataavailable = (ev) => {
            if (ev.data && ev.data.size > 0) chunks.push(ev.data);
          };
          recorder.onstop = () => {
            // stop tracks
            stream.getTracks().forEach(t => t.stop());
          };
          recorder.start();
          isRecording = true;
          voiceBtn.classList.add('text-danger');
        }

        async function stopAndSend() {
          if (!recorder) return;
          const active = getActive();
          if (!active) return;
          if (!window.visionAPI?.isAuthenticated?.()) throw new Error('Please login first.');
          if (getMode() !== 'general') throw new Error('Voice is available in General mode only.');

          const state = active.mode.general;

          // On first voice use per tab+general, remove welcome/suggestions
          if (!state.started) {
            state.started = true;
            messagesEl.innerHTML = '';
          }

          const stopped = new Promise(resolve => {
            recorder.addEventListener('stop', resolve, { once: true });
          });
          recorder.stop();
          await stopped;

          isRecording = false;
          voiceBtn.classList.remove('text-danger');

          const blob = new Blob(chunks, { type: 'audio/webm' });
          const file = new File([blob], 'voice.webm', { type: 'audio/webm' });

          // Render placeholders
          appendUserBubble('[Voice message]');
          const pendingId = appendAssistantPending();
          saveActiveHtml();
          messagesEl.scrollTop = messagesEl.scrollHeight;

          const result = await window.visionAPI.voiceChat(file, state.sessionId);
          if (result?.sessionId) state.sessionId = result.sessionId;
          const textResp = result?.textResponse || '(voice response)';
          replaceAssistantPending(pendingId, textResp);
          state.html = messagesEl.innerHTML;
          messagesEl.scrollTop = messagesEl.scrollHeight;

          // Play audio (best-effort)
          try {
            if (result?.audioBlob) {
              const url = URL.createObjectURL(result.audioBlob);
              const audio = new Audio(url);
              audio.play().catch(() => { });
              audio.onended = () => URL.revokeObjectURL(url);
            }
          } catch { }
        }

        voiceBtn.addEventListener('click', async () => {
          try {
            if (getMode() !== 'general') {
              // keep silent; user can switch mode
              return;
            }

            if (!isRecording) {
              await start();
            } else {
              await stopAndSend();
            }
          } catch (err) {
            isRecording = false;
            voiceBtn.classList.remove('text-danger');
            const active = getActive();
            if (active) {
              appendAssistantPending(); // ensures latest is visible even if template is empty
              const lastPending = messagesEl.querySelector?.('[data-chatbot-pending]');
              if (lastPending) {
                const bubble = lastPending.querySelector?.('div');
                if (bubble) {
                  bubble.textContent = err?.message ? String(err.message) : 'Voice failed.';
                  bubble.classList.remove('bg-body-secondary');
                  bubble.classList.add('bg-danger', 'text-white');
                }
              }
              active.mode.general.html = messagesEl.innerHTML;
              messagesEl.scrollTop = messagesEl.scrollHeight;
            }
          }
        });
      })();

      // Init with first tab
      chatbotOffcanvas.dataset.chatbotMode = chatbotOffcanvas.dataset.chatbotMode || 'general';
      if (modeLabel) modeLabel.textContent = getMode() === 'agent' ? 'Agent' : 'General';
      createTab('New chat 1');
    }

    function initChatbotKeyboardShortcut() {
      // Ctrl+L (or Cmd+L on Mac) to toggle chatbot
      document.addEventListener('keydown', function (e) {
        // Check for Ctrl+L (Windows/Linux) or Cmd+L (Mac)
        if ((e.ctrlKey || e.metaKey) && e.key === 'l' && !e.shiftKey && !e.altKey) {
          // Prevent default browser behavior (focus address bar)
          e.preventDefault();

          const chatbotOffcanvas = document.getElementById('chatbot-offcanvas');
          if (!chatbotOffcanvas || typeof bootstrap === 'undefined') return;

          const offcanvasInstance = bootstrap.Offcanvas.getInstance(chatbotOffcanvas);

          if (offcanvasInstance) {
            // Toggle: if open, close it; if closed, open it
            offcanvasInstance.toggle();
          } else {
            // Create new instance and show
            const newInstance = new bootstrap.Offcanvas(chatbotOffcanvas);
            newInstance.show();
          }
        }
      });
    }

    // Wait for DOM and Bootstrap to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function () {
        // Wait for Bootstrap to be available
        if (typeof bootstrap !== 'undefined') {
          initChatbotPush();
          initChatbotComposer();
          initChatbotTabs();
          initChatbotKeyboardShortcut();
        } else {
          // Wait a bit more for Bootstrap to load
          setTimeout(function () {
            if (typeof bootstrap !== 'undefined') {
              initChatbotPush();
              initChatbotComposer();
              initChatbotTabs();
              initChatbotKeyboardShortcut();
            }
          }, 100);
        }
      });
    } else {
      // DOM already loaded
      if (typeof bootstrap !== 'undefined') {
        initChatbotPush();
        initChatbotComposer();
        initChatbotTabs();
        initChatbotKeyboardShortcut();
      } else {
        setTimeout(function () {
          if (typeof bootstrap !== 'undefined') {
            initChatbotPush();
            initChatbotComposer();
            initChatbotTabs();
            initChatbotKeyboardShortcut();
          }
        }, 100);
      }
    }
  })();
</script>