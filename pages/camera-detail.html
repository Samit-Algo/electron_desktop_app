<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Camera Details - Vision AI</title>

    <!-- Layout Loader - Must be loaded early -->
    <script src="../custom_js/layout-loader.js"></script>
</head>
<body>
    <!-- Page Content Container - This will be replaced by layout loader -->
    <div id="page-content" style="display:none;">
        <div class="content">
            <nav class="mb-3" aria-label="breadcrumb">
                <ol class="breadcrumb mb-0">
                    <li class="breadcrumb-item"><a href="dashboard.html">Dashboard</a></li>
                    <li class="breadcrumb-item active">Camera Details</li>
                </ol>
            </nav>

            <div class="d-flex justify-content-between align-items-start flex-wrap gap-2 mb-3">
                <div>
                    <h2 class="mb-1 text-body-emphasis" id="camera-title">Camera</h2>
                    <p class="text-body-tertiary mb-0 fs-9">Live view + agent monitoring</p>
                </div>
                <div class="d-flex gap-2">
                    <a class="btn btn-phoenix-secondary btn-sm" href="dashboard.html">
                        <span class="fa-solid fa-arrow-left me-1"></span>Back
                    </a>
                </div>
            </div>

            <!-- Reuse Chat page layout: left list + right "conversation" (replaced with video player) -->
            <div class="chat d-flex phoenix-offcanvas-container pt-1 mt-n1 mb-9" id="camera-detail-shell">
                <!-- Left sidebar -->
                <div class="card p-3 p-xl-1 mt-xl-n1 chat-sidebar me-3 phoenix-offcanvas phoenix-offcanvas-start" id="agent-sidebar" style="min-width: 320px;">
                    <!-- Search (same idea as chat) -->
                    <div class="form-icon-container mb-4 d-sm-none d-xl-block">
                        <input class="form-control form-icon-input" id="agent-search" type="text" placeholder="Search agents" />
                        <span class="fas fa-user text-body fs-9 form-icon"></span>
                    </div>

                    <!-- Tabs: All->Active, Read->Scheduled, Unread->Completed -->
                    <ul class="nav nav-phoenix-pills mb-4 d-sm-none d-xl-flex" role="tablist">
                        <li class="nav-item" role="presentation">
                            <a class="nav-link cursor-pointer active" data-agent-filter="active" role="tab" aria-selected="true">Active Agents</a>
                        </li>
                        <li class="nav-item" role="presentation">
                            <a class="nav-link cursor-pointer" data-agent-filter="scheduled" role="tab" aria-selected="false">Scheduled Agents</a>
                        </li>
                        <li class="nav-item" role="presentation">
                            <a class="nav-link cursor-pointer" data-agent-filter="completed" role="tab" aria-selected="false">Completed Agents</a>
                        </li>
                    </ul>

                    <div class="scrollbar" style="max-height: 70vh;">
                        <ul class="nav chat-thread-tab flex-column list" id="agent-list">
                            <li class="nav-item" id="agent-list-loading">
                                <div class="text-body-tertiary fs-9 p-3">Loading agents...</div>
                            </li>
                        </ul>
                    </div>
                </div>

                <!-- Right content: video player replaces chat thread -->
                <div class="card flex-1 phoenix-offcanvas-container">
                    <div class="d-flex flex-column">
                        <div class="card-header p-3 p-md-4 d-flex flex-between-center">
                            <div class="d-flex align-items-center">
                                <span class="fa-solid fa-video text-primary me-2" id="stream-type-icon"></span>
                                <div class="d-flex flex-column flex-md-row align-items-md-center">
                                    <div class="fw-semibold text-body-emphasis me-3" id="camera-header-name">Live Camera</div>
                                    <p class="fs-9 mb-0 me-2">
                                        <span class="fa-solid fa-circle text-success fs-11 me-2" id="camera-status-dot"></span>
                                        <span id="camera-status-text">Live</span>
                                    </p>
                                    <button class="btn btn-phoenix-secondary btn-sm ms-2 d-none" type="button" id="switch-to-camera-btn" title="Switch back to camera stream">
                                        <span class="fa-solid fa-video me-1"></span>Camera View
                                    </button>
                                </div>
                            </div>
                            <div class="d-flex gap-2">
                                <button class="btn btn-icon btn-phoenix-primary" type="button" id="toggle-agent-sidebar" title="Collapse/Expand Agents">
                                    <span class="fa-solid fa-angles-left"></span>
                                </button>
                                <button class="btn btn-icon btn-phoenix-primary" type="button" id="camera-reload" title="Reload">
                                    <span class="fa-solid fa-rotate"></span>
                                </button>
                            </div>
                        </div>

                        <div class="card-body p-0 visionai-right-body">
                            <div class="position-relative bg-black visionai-video-stage">
                                <video id="camera-video" class="w-100 h-100 visionai-video" controls autoplay muted playsinline></video>
                                <!-- Agent overlay canvas (Option A) -->
                                <canvas id="agent-overlay-canvas" class="visionai-agent-overlay"></canvas>

                                <div class="position-absolute bottom-0 start-0 m-3">
                                    <span class="badge bg-dark bg-opacity-75 text-white fs-9" id="camera-overlay-badge">
                                        <span class="fa-solid fa-eye me-1"></span>Live preview
                                    </span>
                                </div>
                            </div>

                            <!-- CCTV-style Timeline (dummy, 24h with zoom) -->
                            <div class="visionai-timeline border-top border-translucent" id="visionai-timeline" aria-label="Camera timeline">
                                <div class="cctv-timeline__header">
                                    <div class="cctv-timeline__title">
                                        <span class="fa-solid fa-clock me-2 text-info"></span>
                                        <span class="fw-semibold">Timeline</span>
                                        <span class="cctv-timeline__subtitle ms-2">Dummy 24h view</span>
                                    </div>
                                    <div class="cctv-timeline__controls" aria-label="Timeline zoom controls">
                                        <button class="btn btn-phoenix-secondary btn-sm cctv-timeline__btn" type="button" id="cctv-zoom-out" title="Zoom out (mouse wheel supported)">
                                            <span class="fa-solid fa-minus"></span>
                                        </button>
                                        <span class="cctv-timeline__zoom-pill" id="cctv-zoom-label" aria-live="polite">24h</span>
                                        <button class="btn btn-phoenix-secondary btn-sm cctv-timeline__btn" type="button" id="cctv-zoom-in" title="Zoom in (mouse wheel supported)">
                                            <span class="fa-solid fa-plus"></span>
                                        </button>
                                    </div>
                                </div>

                                <!-- vis-timeline container (engine handles zoom/pan/scales) -->
                                <div class="cctv-vis" id="cctv-vis"></div>
                                <!-- Event hover popup (custom overlay) -->
                                <div class="cctv-event-popup" id="cctv-event-popup" aria-hidden="true">
                                    <div class="cctv-event-popup__media">
                                        <div class="cctv-event-popup__img-wrap">
                                            <img class="cctv-event-popup__img" id="cctv-event-popup-img" alt="" />
                                        </div>
                                    </div>
                                    <div class="cctv-event-popup__meta">
                                        <div class="cctv-event-popup__title" id="cctv-event-popup-title">Event</div>
                                        <div class="cctv-event-popup__row">
                                            <span class="cctv-event-popup__k">Time</span>
                                            <span class="cctv-event-popup__v" id="cctv-event-popup-time">--:--</span>
                                        </div>
                                        <div class="cctv-event-popup__row">
                                            <span class="cctv-event-popup__k">Agent</span>
                                            <span class="cctv-event-popup__v" id="cctv-event-popup-agent">—</span>
                                        </div>
                                        <div class="cctv-event-popup__row">
                                            <span class="cctv-event-popup__k">Severity</span>
                                            <span class="cctv-event-popup__v" id="cctv-event-popup-sev">—</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="card-footer p-3">
                            <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between">
                                <div class="d-flex gap-2 align-items-center">
                                    <span class="badge badge-phoenix badge-phoenix-info fs-10" id="camera-id-badge">cam</span>
                                    <span class="text-body-tertiary fs-9">Click a tab to filter agents; search to narrow.</span>
                                </div>
                                <a class="btn btn-phoenix-secondary btn-sm" href="events-board.html">
                                    <span class="fa-solid fa-bell me-1"></span>Open Events Board
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <style>
                /* Make the chat-derived layout feel right for video */
                #agent-sidebar .nav-link { user-select: none; }
                #agent-list .nav-link { border-radius: .5rem; }
                #agent-list .agent-item.active {
                    background-color: rgba(var(--phoenix-primary-rgb), 0.1);
                }
                #agent-list .agent-item.active .nav-link {
                    background-color: rgba(var(--phoenix-primary-rgb), 0.05);
                }

                /* Agent overlay canvas (draw detections over camera video) */
                .visionai-video-stage { position: relative; }
                .visionai-agent-overlay {
                    position: absolute;
                    inset: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 4;
                }

                /* Sidebar collapse: hide left panel, let video take full width */
                #camera-detail-shell.visionai-sidebar-collapsed #agent-sidebar { display: none !important; }

                /* Timeline: always visible under the camera (right pane).
                   When the sidebar collapses, the right pane becomes full width, so the timeline does too. */
                #visionai-timeline { display: block; background: #0b0f14; }

                /* No internal scrolling: timeline should push the page naturally */
                .visionai-right-body {
                    overflow: visible;
                    min-height: auto;
                    flex: 0 0 auto;
                }

                /* Make right pane height flexible (avoid any vertical clipping from chat layout styles) */
                #camera-detail-shell,
                #camera-detail-shell > .card,
                #camera-detail-shell .phoenix-offcanvas-container,
                #camera-detail-shell .card {
                    height: auto !important;
                    max-height: none !important;
                    overflow: visible !important;
                }

                /* Video sizing:
                   - Responsive height (no hard fixed px that can cause clipping on small screens)
                   - No crop: always show full frame */
                .visionai-video-stage {
                    height: clamp(320px, 55vh, 620px);
                    background: #000;
                }
                .visionai-video {
                    object-fit: contain !important;
                    object-position: center center !important;
                    background: #000;
                    display: block;
                }

                /* ------------------------------------------------------------------
                   CCTV timeline (dummy 24h + zoom) — pro timeline model + themes
                   Theme tokens: set data-theme="dark|light" on <html> or <body>
                   ------------------------------------------------------------------ */
                :root,
                [data-theme="dark"] {
                    --cctv-bg: #0b0f14;
                    --cctv-header-bg: rgba(0,0,0,0.18);
                    --cctv-header-border: rgba(255,255,255,0.06);
                    --cctv-text: rgba(255,255,255,0.92);
                    --cctv-text-muted: rgba(255,255,255,0.55);
                    --cctv-pill-bg: rgba(0,0,0,0.35);
                    --cctv-pill-border: rgba(255,255,255,0.10);

                    --cctv-bar-bg: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
                    --cctv-bar-border: rgba(255,255,255,0.08);

                    --cctv-grid-minor: rgba(255,255,255,0.06);
                    --cctv-grid-major: rgba(255,255,255,0.12);
                    --cctv-label: rgba(255,255,255,0.70);

                    --cctv-seg-recording: rgba(13, 202, 240, 0.78);
                    --cctv-seg-motion: rgba(13, 110, 253, 0.78);
                    --cctv-seg-event: rgba(25, 135, 84, 0.88);

                    --cctv-now: #13e6ff;
                    --cctv-now-glow: rgba(19, 230, 255, 0.16);
                    --cctv-now-label-bg: rgba(0,0,0,0.75);
                    --cctv-now-label-text: rgba(255,255,255,0.92);

                    --cctv-hover-line: rgba(19, 230, 255, 0.55);
                    --cctv-hover-tip-bg: rgba(0,0,0,0.78);
                    --cctv-hover-tip-text: rgba(255,255,255,0.92);
                }

                [data-theme="light"] {
                    --cctv-bg: #f6f8fb;
                    --cctv-header-bg: rgba(0,0,0,0.04);
                    --cctv-header-border: rgba(0,0,0,0.08);
                    --cctv-text: rgba(0,0,0,0.88);
                    --cctv-text-muted: rgba(0,0,0,0.55);
                    --cctv-pill-bg: rgba(255,255,255,0.70);
                    --cctv-pill-border: rgba(0,0,0,0.10);

                    --cctv-bar-bg: linear-gradient(180deg, rgba(0,0,0,0.04), rgba(0,0,0,0.02));
                    --cctv-bar-border: rgba(0,0,0,0.12);

                    --cctv-grid-minor: rgba(0,0,0,0.10);
                    --cctv-grid-major: rgba(0,0,0,0.18);
                    --cctv-label: rgba(0,0,0,0.65);

                    --cctv-seg-recording: rgba(0, 145, 255, 0.70);
                    --cctv-seg-motion: rgba(0, 180, 120, 0.70);
                    --cctv-seg-event: rgba(255, 140, 0, 0.78);

                    --cctv-now: #00bcd4;
                    --cctv-now-glow: rgba(0, 188, 212, 0.18);
                    --cctv-now-label-bg: rgba(255,255,255,0.90);
                    --cctv-now-label-text: rgba(0,0,0,0.85);

                    --cctv-hover-line: rgba(0, 188, 212, 0.55);
                    --cctv-hover-tip-bg: rgba(255,255,255,0.92);
                    --cctv-hover-tip-text: rgba(0,0,0,0.86);

                    --cctv-popup-bg: rgba(255,255,255,0.96);
                    --cctv-popup-text: rgba(0,0,0,0.88);
                    --cctv-popup-muted: rgba(0,0,0,0.55);
                    --cctv-popup-border: rgba(0,0,0,0.12);
                }

                .cctv-timeline__header {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 12px;
                    padding: 10px 12px;
                    background: var(--cctv-header-bg);
                    border-bottom: 1px solid var(--cctv-header-border);
                }
                .cctv-timeline__title {
                    display: flex;
                    align-items: center;
                    gap: 4px;
                    color: var(--cctv-text);
                }
                .cctv-timeline__subtitle {
                    font-size: 12px;
                    color: var(--cctv-text-muted);
                }
                .cctv-timeline__controls {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }
                .cctv-timeline__zoom-pill {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    min-width: 52px;
                    padding: 4px 10px;
                    border-radius: 999px;
                    font-size: 12px;
                    color: color-mix(in oklab, var(--cctv-text) 92%, transparent);
                    background: var(--cctv-pill-bg);
                    border: 1px solid var(--cctv-pill-border);
                    user-select: none;
                }
                .cctv-timeline__btn {
                    border-color: rgba(255,255,255,0.12) !important;
                }

                /* The timeline block itself */
                .cctv-timeline {
                    width: 100%;
                    padding: 10px 12px 14px 12px;
                    background: var(--cctv-bg);
                }
                .cctv-timeline__labels {
                    position: relative;
                    height: 18px;
                    margin-bottom: 8px;
                    font-size: 12px;
                    color: var(--cctv-label);
                    user-select: none;
                    overflow: hidden;
                    cursor: grab;
                }
                .cctv-timeline__labels.is-panning { cursor: grabbing; }
                .cctv-timeline__label {
                    position: absolute;
                    top: 0;
                    transform: translateX(-50%);
                    white-space: nowrap;
                    letter-spacing: 0.2px;
                }
                .cctv-timeline__bar {
                    position: relative;
                    height: 52px;
                    border-radius: 10px;
                    background: var(--cctv-bar-bg);
                    border: 1px solid var(--cctv-bar-border);
                    overflow: hidden;
                    cursor: grab;
                }
                .cctv-timeline__bar.is-panning { cursor: grabbing; }
                .cctv-timeline__grid {
                    position: absolute;
                    inset: 0;
                    pointer-events: none;
                }
                .cctv-timeline__tick {
                    position: absolute;
                    top: 0;
                    bottom: 0;
                    width: 1px;
                    background: var(--cctv-grid-minor);
                }
                .cctv-timeline__tick--major {
                    background: var(--cctv-grid-major);
                }

                .cctv-timeline__segments {
                    position: absolute;
                    inset: 0;
                    pointer-events: none;
                }
                .cctv-seg {
                    position: absolute;
                    height: 6px;
                    border-radius: 999px;
                    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
                }
                .cctv-seg--recording {
                    background: var(--cctv-seg-recording);
                }
                .cctv-seg--event {
                    background: var(--cctv-seg-event);
                }
                .cctv-seg--motion {
                    background: var(--cctv-seg-motion);
                }

                /* Lanes for thin bars */
                .cctv-seg[data-lane="0"] { top: 14px; }
                .cctv-seg[data-lane="1"] { top: 24px; }
                .cctv-seg[data-lane="2"] { top: 34px; }

                /* Current time marker */
                .cctv-timeline__now {
                    position: absolute;
                    top: 0;
                    bottom: 0;
                    width: 2px;
                    background: var(--cctv-now);
                    box-shadow: 0 0 0 3px var(--cctv-now-glow);
                    z-index: 3;
                    pointer-events: none;
                }
                .cctv-timeline__now::before {
                    content: '';
                    position: absolute;
                    top: -7px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 10px;
                    height: 10px;
                    border-radius: 50%;
                    background: var(--cctv-now);
                    box-shadow: 0 0 0 4px var(--cctv-now-glow);
                }
                .cctv-timeline__now::after {
                    content: attr(data-label);
                    position: absolute;
                    top: -30px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 4px 8px;
                    border-radius: 999px;
                    font-size: 11px;
                    line-height: 1;
                    white-space: nowrap;
                    color: var(--cctv-now-label-text);
                    background: var(--cctv-now-label-bg);
                    border: 1px solid color-mix(in oklab, var(--cctv-now) 35%, transparent);
                }
                .cctv-timeline__now.is-clamped-left::after,
                .cctv-timeline__now.is-clamped-right::after {
                    content: attr(data-label) " (off-screen)";
                }

                /* Hover cursor */
                .cctv-timeline__hover {
                    position: absolute;
                    top: 0;
                    bottom: 0;
                    width: 1px;
                    background: var(--cctv-hover-line);
                    z-index: 2;
                    pointer-events: none;
                    opacity: 0;
                    transition: opacity 80ms ease;
                }
                .cctv-timeline__hover.is-visible { opacity: 1; }
                .cctv-timeline__hover-tip {
                    position: absolute;
                    top: 6px;
                    transform: translateX(-50%);
                    padding: 4px 8px;
                    border-radius: 999px;
                    font-size: 11px;
                    line-height: 1;
                    white-space: nowrap;
                    color: var(--cctv-hover-tip-text);
                    background: var(--cctv-hover-tip-bg);
                    border: 1px solid color-mix(in oklab, var(--cctv-hover-line) 40%, transparent);
                    z-index: 4;
                    pointer-events: none;
                    opacity: 0;
                    transition: opacity 80ms ease;
                }
                .cctv-timeline__hover-tip.is-visible { opacity: 1; }

                /* ------------------------------------------------------------------
                   vis-timeline skinning (override defaults)
                   ------------------------------------------------------------------ */
                .cctv-vis {
                    width: 100%;
                    background: var(--cctv-bg);
                    padding: 10px 12px 12px 12px;
                }

                .cctv-vis .vis-timeline {
                    border: 1px solid var(--cctv-bar-border) !important;
                    border-radius: 10px !important;
                    background: var(--cctv-bar-bg) !important;
                }
                .cctv-vis .vis-panel,
                .cctv-vis .vis-panel.vis-center,
                .cctv-vis .vis-panel.vis-left,
                .cctv-vis .vis-panel.vis-right,
                .cctv-vis .vis-panel.vis-top,
                .cctv-vis .vis-panel.vis-bottom {
                    background: transparent !important;
                    border: 0 !important;
                }

                /* Dense / compact layout */
                .cctv-vis .vis-time-axis {
                    border: 0 !important;
                    background: transparent !important;
                }
                .cctv-vis .vis-time-axis .vis-text {
                    color: var(--cctv-label) !important;
                    font-size: 12px !important;
                    letter-spacing: 0.2px;
                }
                .cctv-vis .vis-itemset {
                    border: 0 !important;
                }

                /* Grid hierarchy */
                .cctv-vis .vis-grid.vis-major { border-color: var(--cctv-grid-major) !important; }
                .cctv-vis .vis-grid.vis-minor { border-color: var(--cctv-grid-minor) !important; }

                /* Group labels: compact */
                .cctv-vis .vis-labelset .vis-label {
                    color: var(--cctv-text) !important;
                    background: transparent !important;
                    border-color: transparent !important;
                }
                .cctv-vis .vis-labelset .vis-label .vis-inner {
                    padding: 4px 8px !important;
                    opacity: 0.75;
                    font-size: 12px !important;
                }
                .cctv-vis .vis-group { border-color: color-mix(in oklab, var(--cctv-grid-minor) 80%, transparent) !important; }

                /* Activity bars */
                .cctv-vis .vis-item {
                    border: 0 !important;
                    border-radius: 999px !important;
                    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.18);
                    height: 8px;
                }
                .cctv-vis .vis-item.vis-range .vis-item-content {
                    padding: 0 !important;
                    line-height: 0 !important;
                }
                .cctv-vis .vis-item.cctv-recording { background: var(--cctv-seg-recording) !important; }
                .cctv-vis .vis-item.cctv-motion { background: var(--cctv-seg-motion) !important; }
                .cctv-vis .vis-item.cctv-event { background: var(--cctv-seg-event) !important; }

                /* NOW playhead via custom time */
                .cctv-vis .vis-custom-time {
                    background: var(--cctv-now) !important;
                    width: 2px !important;
                    box-shadow: 0 0 0 3px var(--cctv-now-glow);
                    pointer-events: none;
                }
                .cctv-vis .vis-custom-time::before {
                    content: '';
                    position: absolute;
                    top: -7px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 10px;
                    height: 10px;
                    border-radius: 50%;
                    background: var(--cctv-now);
                    box-shadow: 0 0 0 4px var(--cctv-now-glow);
                }
                .cctv-vis .vis-custom-time .vis-custom-time-marker {
                    color: var(--cctv-now-label-text) !important;
                    background: var(--cctv-now-label-bg) !important;
                    border: 1px solid color-mix(in oklab, var(--cctv-now) 35%, transparent) !important;
                    border-radius: 999px !important;
                    padding: 4px 8px !important;
                    font-size: 11px !important;
                }

                /* ------------------------------------------------------------------
                   Timeline event hover popup
                   ------------------------------------------------------------------ */
                .cctv-event-popup {
                    position: fixed;
                    z-index: 9999;
                    display: none;
                    width: 320px;
                    max-width: 360px;
                    border-radius: 14px;
                    background: var(--cctv-popup-bg, rgba(0,0,0,0.88));
                    color: var(--cctv-popup-text, rgba(255,255,255,0.92));
                    border: 1px solid var(--cctv-popup-border, rgba(255,255,255,0.12));
                    box-shadow: 0 12px 40px rgba(0,0,0,0.35);
                    overflow: hidden;
                    pointer-events: none;
                }
                :root,
                [data-theme="dark"] {
                    --cctv-popup-bg: rgba(9, 12, 18, 0.92);
                    --cctv-popup-text: rgba(255,255,255,0.92);
                    --cctv-popup-muted: rgba(255,255,255,0.60);
                    --cctv-popup-border: rgba(255,255,255,0.10);
                }
                .cctv-event-popup[data-show="true"] { display: grid; grid-template-columns: 110px 1fr; }
                .cctv-event-popup__media { background: rgba(0,0,0,0.10); }
                .cctv-event-popup__img-wrap {
                    width: 110px;
                    height: 110px;
                    background: rgba(0,0,0,0.20);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                .cctv-event-popup__img {
                    width: 110px;
                    height: 110px;
                    object-fit: cover;
                    display: none;
                }
                .cctv-event-popup__meta { padding: 10px 12px; }
                .cctv-event-popup__title {
                    font-weight: 700;
                    font-size: 13px;
                    margin-bottom: 6px;
                    line-height: 1.2;
                }
                .cctv-event-popup__row {
                    display: flex;
                    align-items: baseline;
                    justify-content: space-between;
                    gap: 10px;
                    font-size: 12px;
                    line-height: 1.3;
                    padding: 2px 0;
                }
                .cctv-event-popup__k { color: var(--cctv-popup-muted); }
                .cctv-event-popup__v { color: var(--cctv-popup-text); text-align: right; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
                .cctv-event-popup__loading {
                    font-size: 11px;
                    color: var(--cctv-popup-muted);
                }

                .visionai-tooltip {
                    position: fixed;
                    z-index: 9999;
                    max-width: 320px;
                    padding: 8px 10px;
                    border-radius: 10px;
                    background: rgba(0,0,0,0.85);
                    color: #fff;
                    font-size: 12px;
                    line-height: 1.25;
                    pointer-events: none;
                    opacity: 0;
                    transform: translateY(6px);
                    transition: opacity .12s ease, transform .12s ease;
                }
                .visionai-tooltip[data-show="true"] {
                    opacity: 1;
                    transform: translateY(0);
                }
            </style>

            <!-- Page script: executed by layout-loader after injection -->
            <script type="text/visionai-page-script">
                (function () {
                    'use strict';

                    // Get camera ID from URL - handle both SPA navigation and direct navigation
                    async function getCameraId() {
                        // Try current location first
                        let params = new URLSearchParams(window.location.search);
                        let camId = params.get('camera');
                        
                        // If not found, wait a bit for SPA navigation to update the URL
                        if (!camId) {
                            // Wait for URL to be updated by pushState (happens after script execution)
                            for (let i = 0; i < 10; i++) {
                                await new Promise(resolve => setTimeout(resolve, 50));
                                params = new URLSearchParams(window.location.search);
                                camId = params.get('camera');
                                if (camId) break;
                                
                                // Also check history state
                                if (window.history.state && window.history.state.url) {
                                    try {
                                        const url = new URL(window.history.state.url, window.location.origin);
                                        camId = url.searchParams.get('camera');
                                        if (camId) break;
                                    } catch (e) {
                                        // ignore
                                    }
                                }
                            }
                        }
                        
                        // If still not found, try parsing the current pathname (fallback)
                        if (!camId) {
                            const match = window.location.pathname.match(/camera-detail\.html\?camera=([^&]+)/);
                            if (match) {
                                camId = decodeURIComponent(match[1]);
                            }
                        }
                        
                        // Last resort: check if URL was stored by layout-loader
                        if (!camId && window.__visionaiCurrentUrl) {
                            try {
                                const url = new URL(window.__visionaiCurrentUrl, window.location.origin);
                                camId = url.searchParams.get('camera');
                            } catch (e) {
                                // ignore
                            }
                        }
                        
                        return camId;
                    }

                    // Initialize camera with async camera ID retrieval
                    async function init() {
                        const camId = await getCameraId();

                        if (!camId) {
                            console.error('No camera ID provided. URL:', window.location.href);
                            console.error('Search params:', window.location.search);
                            console.error('History state:', window.history.state);
                            statusText.textContent = 'No camera ID';
                            return;
                        }
                        
                        console.log('Camera ID from URL:', camId);
                        
                        // Store camId for use by initCamera
                        currentCameraId = camId;
                        // Expose camera context to chatbot (for agent chat / zone drawing)
                        try {
                            window.__visionaiActiveCameraId = camId;
                            localStorage.setItem('vision_active_camera_id', camId);
                        } catch (_) {
                            // ignore
                        }
                        
                        // Now initialize camera
                        await initCamera();
                    }

                    const titleEl = document.getElementById('camera-title');
                    const headerEl = document.getElementById('camera-header-name');
                    const idBadge = document.getElementById('camera-id-badge');
                    const videoEl = document.getElementById('camera-video');
                    const containerEl = videoEl?.closest('.position-relative');
                    const shellEl = document.getElementById('camera-detail-shell');
                    const statusDot = document.getElementById('camera-status-dot');
                    const statusText = document.getElementById('camera-status-text');
                    const overlayBadge = document.getElementById('camera-overlay-badge');
                    const streamTypeIcon = document.getElementById('stream-type-icon');
                    const switchToCameraBtn = document.getElementById('switch-to-camera-btn');
                    const overlayCanvas = document.getElementById('agent-overlay-canvas');
                    
                    // Store original canvas parent for restoring after fullscreen
                    let originalCanvasParent = null;
                    let originalCanvasNextSibling = null;

                    let livePlayer = null;
                    let cameraData = null;
                    let isUserSeeking = false;
                    let currentCameraId = null;
                    let selectedAgentId = null;
                    let overlayWs = null;
                    let overlayLastFrameIndex = null;
                    let overlayLastTimestamp = null;  // Track latest overlay timestamp for staleness check
                    let overlayStalenessCheckInterval = null;  // Interval to check for stale overlays

                    // Register SPA cleanup hook so navigating away closes WS + MSE resources.
                    window.__visionaiPageCleanup = () => {
                        try {
                            if (livePlayer && typeof livePlayer.destroy === 'function') {
                                livePlayer.destroy();
                            }
                        } catch {
                            // ignore
                        }
                        livePlayer = null;
                        try { overlayWs?.close?.(); } catch {}
                        overlayWs = null;
                    };

                    function loadScriptOnce(src) {
                        return new Promise((resolve, reject) => {
                            if (document.querySelector('script[data-visionai="true"][src="' + src + '"]')) return resolve();
                            const s = document.createElement('script');
                            s.src = src;
                            s.defer = true;
                            s.onload = resolve;
                            s.onerror = reject;
                            s.setAttribute('data-visionai', 'true');
                            document.head.appendChild(s);
                        });
                    }

                    // Wait for dependencies to be ready
                    async function waitForDependencies() {
                        let attempts = 0;
                        const maxAttempts = 50;
                        
                        while (attempts < maxAttempts) {
                            if (window.visionAPI && window.visionAPI.isAuthenticated && window.visionAPI.isAuthenticated() && window.createWsFmp4Player) {
                                return true;
                            }
                            // Ensure WS fMP4 player helper is loaded
                            if (!window.createWsFmp4Player) {
                                try {
                                    await loadScriptOnce('../custom_js/ws-fmp4-player.js');
                                } catch (e) {
                                    // keep retrying
                                }
                            }
                            await new Promise(resolve => setTimeout(resolve, 100));
                            attempts++;
                        }
                        
                        return false;
                    }

                    // Load camera data and initialize live player
                    async function initCamera() {
                        // Use the stored camera ID
                        const camId = currentCameraId;
                        if (!camId) {
                            console.error('Camera ID not available');
                            statusText.textContent = 'No camera ID';
                            return;
                        }
                        try {
                            // Wait for dependencies
                            const depsReady = await waitForDependencies();
                            if (!depsReady) {
                                console.error('Dependencies not ready');
                                statusText.textContent = 'Loading dependencies...';
                                return;
                            }

                            // Get camera details from API
                            try {
                                cameraData = await window.visionAPI.getCamera(camId);
                                titleEl.textContent = cameraData.name || camId;
                                headerEl.textContent = cameraData.name || camId;
                    idBadge.textContent = camId;
                            } catch (error) {
                                console.warn('Error fetching camera data:', error);
                                // Fallback if API not available
                                titleEl.textContent = camId;
                                headerEl.textContent = camId;
                                idBadge.textContent = camId;
                            }

                            // Initialize live player (WS fMP4 -> MSE)
                            await initLivePlayer();

                            // Load agents list for this camera
                            await loadAgentsForCamera();
                        } catch (error) {
                            console.error('Error initializing camera:', error);
                            statusDot?.classList.remove('text-success');
                            statusDot?.classList.add('text-warning');
                            statusText.textContent = 'Error: ' + (error.message || 'Failed to load');
                        }
                    }

                    async function initLivePlayer() {
                        // Use the stored camera ID
                        const camId = currentCameraId;
                        if (!camId) {
                            console.error('Camera ID not available for live player');
                            return;
                        }
                        
                        if (!window.visionAPI || !window.visionAPI.isAuthenticated || !window.visionAPI.isAuthenticated()) {
                            console.error('Not authenticated');
                            statusText.textContent = 'Please login';
                            statusDot?.classList.add('text-warning');
                            return;
                        }

                        if (!window.createWsFmp4Player) {
                            console.error('WS fMP4 player not loaded');
                            statusText.textContent = 'Player missing';
                            statusDot?.classList.add('text-warning');
                            return;
                        }
                        
                        // Ensure video element is ready
                        if (!videoEl) {
                            console.error('Video element not found');
                            statusText.textContent = 'Video element not found';
                            return;
                        }

                        // Destroy existing player if any
                        if (livePlayer && typeof livePlayer.destroy === 'function') {
                            livePlayer.destroy();
                            livePlayer = null;
                        }

                        let wsUrl = null;
                        try {
                            // Camera stream from vision backend (always on)
                            wsUrl = window.visionAPI.getLiveWsURL(camId);
                        } catch (e) {
                            statusText.textContent = 'Auth error';
                            statusDot?.classList.add('text-warning');
                            return;
                        }

                        const mimeCodec = window.visionAPI.getLiveMimeCodec();

                        statusText.textContent = 'Connecting...';
                        statusDot?.classList.remove('text-success');
                        statusDot?.classList.add('text-warning');

                        // Base header (overlay will adjust badge text)
                        headerEl.textContent = cameraData?.name || camId || 'Live Camera';
                        if (streamTypeIcon) {
                            streamTypeIcon.className = 'fa-solid fa-video text-primary me-2';
                        }
                        if (overlayBadge) {
                            overlayBadge.innerHTML = '<span class="fa-solid fa-eye me-1"></span>Live preview';
                        }
                        if (switchToCameraBtn) {
                            switchToCameraBtn.classList.add('d-none');
                        }

                        livePlayer = window.createWsFmp4Player({
                            videoEl,
                            wsUrl,
                            mimeCodec,
                            bufferSeconds: 60,
                            onState: (ev) => {
                                if (!ev || !ev.state) return;

                                if (ev.state === 'connecting') {
                                    statusText.textContent = 'Connecting...';
                                    return;
                                }
                                if (ev.state === 'ws-open') {
                                    statusText.textContent = 'Starting...';
                                    return;
                                }
                                if (ev.state === 'first-append') {
                                    statusDot?.classList.remove('text-warning');
                                    statusDot?.classList.add('text-success');
                                    statusText.textContent = 'Live';
                                    try {
                                        videoEl.play().catch(() => {});
                                    } catch {}
                                    return;
                                }
                                if (ev.state === 'stalled') {
                                    statusText.textContent = 'Stalled...';
                                    return;
                                }
                                if (ev.state === 'append-error' || ev.state === 'error') {
                                    statusDot?.classList.remove('text-success');
                                    statusDot?.classList.add('text-warning');
                                    statusText.textContent = 'Stream error';
                                    return;
                                }
                            }
                        });

                        // Sync video position with timeline
                        // NOTE: Timeline-to-video sync is not implemented yet (timeline is an evidence/event UI only).
                        // Keep these hooks guarded to avoid breaking the page.
                        function updateTimelineFromVideo() {
                            // future: map videoEl.currentTime to a timeline playhead
                        }
                        videoEl.addEventListener('timeupdate', () => {
                            if (!isUserSeeking && videoEl.buffered.length > 0) {
                                if (typeof updateTimelineFromVideo === 'function') updateTimelineFromVideo();
                            }
                        });

                        // Handle user seeking in video controls
                        videoEl.addEventListener('seeked', () => {
                            isUserSeeking = false;
                            if (typeof updateTimelineFromVideo === 'function') updateTimelineFromVideo();
                        });
                    }

                    // Function to switch to agent stream
                    function clearOverlayCanvas() {
                        if (!overlayCanvas) return;
                        try {
                            const ctx = overlayCanvas.getContext('2d');
                            if (ctx) ctx.clearRect(0, 0, overlayCanvas.width || 0, overlayCanvas.height || 0);
                        } catch {}
                    }

                    function closeOverlayWs() {
                        try { overlayWs?.close?.(); } catch {}
                        overlayWs = null;
                        overlayLastFrameIndex = null;
                        overlayLastTimestamp = null;
                        if (overlayStalenessCheckInterval) {
                            clearInterval(overlayStalenessCheckInterval);
                            overlayStalenessCheckInterval = null;
                        }
                    }

                    function resizeOverlayCanvasToVideo() {
                        if (!overlayCanvas || !videoEl) return;
                        
                        // Always use video element's actual displayed dimensions
                        // This works correctly in both normal and fullscreen modes
                        // (getBoundingClientRect gives actual displayed size even in fullscreen)
                        const rect = videoEl.getBoundingClientRect();
                        const dpr = window.devicePixelRatio || 1;
                        const w = Math.max(1, Math.round(rect.width * dpr));
                        const h = Math.max(1, Math.round(rect.height * dpr));
                        if (overlayCanvas.width !== w) overlayCanvas.width = w;
                        if (overlayCanvas.height !== h) overlayCanvas.height = h;
                    }

                    function drawOverlay(payload) {
                        if (!overlayCanvas || !videoEl) return;
                        if (!payload || payload.type !== 'agent_overlay') return;

                        // Store the last payload for redrawing on fullscreen changes
                        window.__visionaiLastOverlayPayload = payload;

                        resizeOverlayCanvasToVideo();
                        const ctx = overlayCanvas.getContext('2d');
                        if (!ctx) return;

                        // Always use video element's actual displayed dimensions
                        // This works correctly in both normal and fullscreen modes
                        const rect = videoEl.getBoundingClientRect();
                        const dpr = window.devicePixelRatio || 1;
                        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                        ctx.clearRect(0, 0, rect.width, rect.height);

                        const srcW = Number(payload.width || 0);
                        const srcH = Number(payload.height || 0);
                        if (!srcW || !srcH) return;

                        const scaleX = rect.width / srcW;
                        const scaleY = rect.height / srcH;

                        // Draw zones (polygons and lines) first (if present)
                        let zones = Array.isArray(payload.zones) ? payload.zones : [];
                        // Fallback to single zone for backward compatibility
                        if (zones.length === 0 && payload.zone) {
                            zones.push(payload.zone);
                        }
                        const zoneViolated = payload.zone_violated || false;
                        
                        // Draw each zone
                        for (const zone of zones) {
                            if (!zone || !zone.coordinates || !Array.isArray(zone.coordinates)) continue;
                            
                            const coords = zone.coordinates;
                            const zoneType = (zone.type || 'polygon').toLowerCase();
                            
                            if (zoneType === 'polygon' && coords.length >= 3) {
                                // Draw polygon zone (restricted zone)
                                // Color changes based on violation: red when violated, green when safe
                                const fillColor = zoneViolated ? 'rgba(255, 0, 0, 0.25)' : 'rgba(0, 255, 0, 0.08)';
                                const strokeColor = zoneViolated ? 'rgba(255, 0, 0, 0.9)' : 'rgba(0, 255, 0, 0.6)';
                                const lineWidth = zoneViolated ? 4 : 2;
                                
                                ctx.beginPath();
                                coords.forEach((point, i) => {
                                    if (Array.isArray(point) && point.length >= 2) {
                                        const x = point[0] * srcW * scaleX;
                                        const y = point[1] * srcH * scaleY;
                                        if (i === 0) {
                                            ctx.moveTo(x, y);
                                        } else {
                                            ctx.lineTo(x, y);
                                        }
                                    }
                                });
                                ctx.closePath();
                                ctx.fillStyle = fillColor;
                                ctx.fill();
                                ctx.lineWidth = lineWidth;
                                ctx.strokeStyle = strokeColor;
                                ctx.stroke();
                                
                                // Add "VIOLATION!" text when zone is violated
                                if (zoneViolated && coords.length > 0) {
                                    // Calculate center of polygon for label placement
                                    let centerX = 0, centerY = 0;
                                    coords.forEach(point => {
                                        if (Array.isArray(point) && point.length >= 2) {
                                            centerX += point[0] * srcW * scaleX;
                                            centerY += point[1] * srcH * scaleY;
                                        }
                                    });
                                    centerX /= coords.length;
                                    centerY /= coords.length;
                                    
                                    // Draw violation text
                                    ctx.font = 'bold 16px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
                                    ctx.fillStyle = 'rgba(255, 0, 0, 1)';
                                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                                    ctx.lineWidth = 3;
                                    const text = '⚠ VIOLATION!';
                                    const textMetrics = ctx.measureText(text);
                                    const textX = centerX - textMetrics.width / 2;
                                    const textY = centerY;
                                    ctx.strokeText(text, textX, textY);
                                    ctx.fillText(text, textX, textY);
                                }
                            } else if (zoneType === 'line' && coords.length === 2) {
                                // Draw counting line
                                const p1 = coords[0];
                                const p2 = coords[1];
                                if (Array.isArray(p1) && Array.isArray(p2) && p1.length >= 2 && p2.length >= 2) {
                                    ctx.beginPath();
                                    ctx.moveTo(p1[0] * srcW * scaleX, p1[1] * srcH * scaleY);
                                    ctx.lineTo(p2[0] * srcW * scaleX, p2[1] * srcH * scaleY);
                                    ctx.lineWidth = 4;
                                    ctx.strokeStyle = 'rgba(255, 165, 0, 0.9)';
                                    ctx.stroke();
                                    
                                    // Draw endpoints
                                    ctx.fillStyle = 'rgba(255, 165, 0, 1)';
                                    ctx.beginPath();
                                    ctx.arc(p1[0] * srcW * scaleX, p1[1] * srcH * scaleY, 6, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.beginPath();
                                    ctx.arc(p2[0] * srcW * scaleX, p2[1] * srcH * scaleY, 6, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                        }

                        // Draw detection boxes (if present)
                        if (payload.detections) {
                            const det = payload.detections || {};
                            const boxes = Array.isArray(det.boxes) ? det.boxes : [];
                            const classes = Array.isArray(det.classes) ? det.classes : [];
                            const scores = Array.isArray(det.scores) ? det.scores : [];
                            
                            // Get line crossing and restricted-zone information
                            const line_crossed_indices = Array.isArray(payload.line_crossed_indices) ? payload.line_crossed_indices : [];
                            const line_crossed = payload.line_crossed || false;
                            const zone_violated = payload.zone_violated || false;
                            const fire_detected = payload.fire_detected || false;
                            const track_info = Array.isArray(payload.track_info) ? payload.track_info : [];
                            const in_zone_indices = Array.isArray(payload.in_zone_indices) ? payload.in_zone_indices : [];
                            const inZoneSet = new Set(in_zone_indices);
                            
                            ctx.lineWidth = 2;
                            ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';

                            // Create a map of detection index to track info for quick lookup
                            // Use IoU (Intersection over Union) for better matching
                            const detectionToTrackMap = new Map();
                            for (const track of track_info) {
                                if (track.bbox && Array.isArray(track.bbox) && track.bbox.length >= 4) {
                                    let bestMatchIdx = -1;
                                    let bestIoU = 0;
                                    
                                    // Find best matching detection by IoU
                                    for (let i = 0; i < boxes.length; i++) {
                                        const detBox = boxes[i];
                                        if (!Array.isArray(detBox) || detBox.length < 4) continue;
                                        
                                        // Calculate IoU
                                        const trackBox = track.bbox;
                                        const overlapLeft = Math.max(trackBox[0], detBox[0]);
                                        const overlapTop = Math.max(trackBox[1], detBox[1]);
                                        const overlapRight = Math.min(trackBox[2], detBox[2]);
                                        const overlapBottom = Math.min(trackBox[3], detBox[3]);
                                        
                                        if (overlapRight > overlapLeft && overlapBottom > overlapTop) {
                                            const intersection = (overlapRight - overlapLeft) * (overlapBottom - overlapTop);
                                            const trackArea = (trackBox[2] - trackBox[0]) * (trackBox[3] - trackBox[1]);
                                            const detArea = (detBox[2] - detBox[0]) * (detBox[3] - detBox[1]);
                                            const union = trackArea + detArea - intersection;
                                            
                                            if (union > 0) {
                                                const iou = intersection / union;
                                                if (iou > bestIoU && iou >= 0.3) {
                                                    bestIoU = iou;
                                                    bestMatchIdx = i;
                                                }
                                            }
                                        }
                                    }
                                    
                                    if (bestMatchIdx >= 0 && !detectionToTrackMap.has(bestMatchIdx)) {
                                        detectionToTrackMap.set(bestMatchIdx, track);
                                    }
                                }
                            }

                            // Draw center points for all tracks in GREEN (always visible)
                            let centerPointsDrawn = 0;
                            for (const track of track_info) {
                                if (track.center && Array.isArray(track.center) && track.center.length >= 2) {
                                    // Backend sends center in absolute pixel coordinates (not percentages)
                                    // So we need to scale them to match video display size
                                    const centerX = track.center[0] * scaleX;
                                    const centerY = track.center[1] * scaleY;
                                    
                                    // Always draw center point in GREEN (larger and more visible)
                                    ctx.beginPath();
                                    ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);  // Increased radius from 6 to 8
                                    ctx.fillStyle = 'rgba(0, 255, 0, 1.0)';  // Green for all center points
                                    ctx.fill();
                                    ctx.strokeStyle = 'rgba(255, 255, 255, 1.0)';
                                    ctx.lineWidth = 3;  // Increased from 2 to 3
                                    ctx.stroke();
                                    
                                    // Draw track ID near center point
                                    if (track.track_id !== undefined) {
                                        ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                                        ctx.font = 'bold 12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';  // Made bold and larger
                                        ctx.fillText(`ID:${track.track_id}`, centerX + 10, centerY - 8);
                                    }
                                    
                                    centerPointsDrawn++;
                                }
                            }

                            // Get detection colors from payload (yellow when touching, green otherwise)
                            const detectionColors = Array.isArray(det.colors) ? det.colors : [];
                            
                            for (let i = 0; i < boxes.length; i++) {
                                const b = boxes[i];
                                if (!Array.isArray(b) || b.length < 4) continue;
                                const x1 = Number(b[0]), y1 = Number(b[1]), x2 = Number(b[2]), y2 = Number(b[3]);
                                if (!Number.isFinite(x1 + y1 + x2 + y2)) continue;

                                const dx = x1 * scaleX;
                                const dy = y1 * scaleY;
                                const dw = Math.max(0, (x2 - x1) * scaleX);
                                const dh = Math.max(0, (y2 - y1) * scaleY);
                                
                                // Get track info for this detection
                                const track = detectionToTrackMap.get(i);
                                const isCounted = track && track.counted === true;
                                const crossDirection = track ? track.direction : null;
                                
                                // Determine box color based on detection type:
                                // - RED: Fire detected or zone violation (safety-critical)
                                // - ORANGE: Crossed Side 2 → Side 1 (entry/ADD direction)
                                // - YELLOW: Crossed Side 1 → Side 2 (exit/OUT direction)
                                // - GREEN: Normal detection (not crossed yet)
                                let boxColor, fillColor;
                                
                                // Check if this is a fire-related class (use class name so red works even if payload lags)
                                const clsLower = String(classes[i] || '').toLowerCase();
                                const isFireClass = clsLower.includes('fire') || clsLower.includes('flame') || clsLower.includes('smoke');
                                
                                if (isFireClass || (fire_detected && isFireClass)) {
                                    // RED for fire detection (safety-critical, highest priority)
                                    // Use class name so fire boxes are always red when agent is fire detection
                                    boxColor = 'rgba(255, 0, 0, 0.95)';
                                    fillColor = 'rgba(255, 0, 0, 0.35)';
                                } else if (inZoneSet.size > 0 && inZoneSet.has(i)) {
                                    // Restricted zone: red only for this detection (inside zone)
                                    boxColor = 'rgba(255, 0, 0, 0.95)';
                                    fillColor = 'rgba(255, 0, 0, 0.3)';
                                } else if (zone_violated && inZoneSet.size === 0) {
                                    // Legacy: no in_zone_indices – all boxes red when zone violated
                                    boxColor = 'rgba(255, 0, 0, 0.95)';
                                    fillColor = 'rgba(255, 0, 0, 0.3)';
                                } else if (isCounted && crossDirection === 'entry') {
                                    // ORANGE when crossed from Side 2 → Side 1 (ADD)
                                    boxColor = 'rgba(255, 165, 0, 0.95)';
                                    fillColor = 'rgba(255, 165, 0, 0.3)';
                                } else if (isCounted && crossDirection === 'exit') {
                                    // YELLOW when crossed from Side 1 → Side 2 (OUT)
                                    boxColor = 'rgba(255, 255, 0, 0.95)';
                                    fillColor = 'rgba(255, 255, 0, 0.3)';
                                } else {
                                    // GREEN for normal detection (not crossed yet)
                                    boxColor = 'rgba(0, 255, 0, 0.95)';
                                    fillColor = 'rgba(0, 255, 0, 0.2)';
                                }
                                
                                ctx.strokeStyle = boxColor;
                                ctx.fillStyle = fillColor;
                                ctx.lineWidth = 3;
                                ctx.strokeRect(dx, dy, dw, dh);
                                ctx.fillRect(dx, dy, dw, dh);

                                const cls = String(classes[i] || '');
                                const sc = Number(scores[i] || 0);
                                let label = cls ? `${cls}${Number.isFinite(sc) && sc ? ` ${(sc).toFixed(2)}` : ''}` : '';
                                
                                // Add special labels based on detection type
                                let labelColor = 'rgba(255, 255, 255, 1.0)'; // Default white
                                
                                if (isFireClass) {
                                    // RED label with fire indicator (any fire/flame/smoke class)
                                    label = `🔥 FIRE! ${Number.isFinite(sc) ? (sc).toFixed(2) : ''}`.trim();
                                    labelColor = 'rgba(255, 50, 50, 1.0)'; // Bright red text
                                } else if (isCounted && crossDirection === 'entry') {
                                    // Add direction label when crossed
                                    // - ORANGE text for ADD (Side 2 → Side 1)
                                    label = label ? `ADD! ${label}` : 'ADD!';
                                    labelColor = 'rgba(255, 165, 0, 1.0)'; // Orange text
                                } else if (isCounted && crossDirection === 'exit') {
                                    // - YELLOW text for OUT (Side 1 → Side 2)
                                    label = label ? `OUT! ${label}` : 'OUT!';
                                    labelColor = 'rgba(255, 255, 0, 1.0)'; // Yellow text
                                }
                                
                                if (label) {
                                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                    ctx.fillRect(dx, dy - 18, label.length * 7, 16);
                                    ctx.fillStyle = labelColor;
                                    ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif';
                                    const tx = dx + 4;
                                    const ty = Math.max(14, dy - 6);
                                    ctx.fillText(label, tx, ty);
                                }
                            }
                            
                            // Show alert in console when line is crossed
                            if (line_crossed && line_crossed_indices.length > 0) {
                                console.warn('🚨 [LINE CROSSING]', {
                                    count: line_crossed_indices.length,
                                    indices: line_crossed_indices,
                                    frame_index: payload.frame_index
                                });
                            }
                            
                            // Show alert in console when fire is detected
                            if (fire_detected) {
                                console.warn('🔥🚨 [FIRE DETECTED]', {
                                    num_boxes: boxes.length,
                                    classes: classes,
                                    frame_index: payload.frame_index
                                });
                            }
                        }
                    }

                    async function openOverlayWsForAgent(agentId, agentName) {
                        closeOverlayWs();
                        clearOverlayCanvas();
                        selectedAgentId = agentId || null;

                        if (!agentId) return;
                        if (!window.visionAPI || !window.visionAPI.isAuthenticated || !window.visionAPI.isAuthenticated()) return;
                        if (!window.visionAPI.getAgentOverlayWsURL) {
                            console.warn('visionAPI.getAgentOverlayWsURL missing');
                            return;
                        }

                        let wsUrl = null;
                        try {
                            wsUrl = window.visionAPI.getAgentOverlayWsURL(agentId);
                        } catch (e) {
                            console.warn('Overlay WS auth error', e);
                            return;
                        }

                        overlayWs = new WebSocket(wsUrl);
                        overlayWs.onmessage = (evt) => {
                            try {
                                const data = JSON.parse(evt.data);
                                
                                // Debug logging for overlay data
                                if (data && data.type === 'agent_overlay') {
                                    const logData = {
                                        frame_index: data.frame_index,
                                        has_detections: !!data.detections,
                                        num_boxes: data.detections?.boxes?.length || 0,
                                        has_zone: !!data.zone,
                                        zone_type: data.zone?.type,
                                        zone_coords_length: data.zone?.coordinates?.length || 0,
                                        zone_violated: data.zone_violated || false
                                    };
                                    
                                    // Show warning if zone is violated
                                    if (data.zone_violated) {
                                        console.warn('🚨 [Overlay] ZONE VIOLATION DETECTED!', logData);
                                    } else {
                                        console.log('[Overlay] Received data:', logData);
                                    }
                                }
                                
                                if (data && data.frame_index != null) {
                                    if (overlayLastFrameIndex === data.frame_index) return;
                                    overlayLastFrameIndex = data.frame_index;
                                }
                                
                                // Update timestamp (use ts_monotonic from backend, or current time as fallback)
                                // ts_monotonic is in seconds, convert to milliseconds
                                overlayLastTimestamp = data.ts_monotonic ? (data.ts_monotonic * 1000) : Date.now();
                                
                                // Always draw latest overlay (no timestamp matching for live stream)
                                // This works even if YOLO processing is slower than video playback
                                drawOverlay(data);
                            } catch (e) {
                                console.error('[Overlay] Error processing message:', e);
                            }
                        };
                        overlayWs.onclose = () => {
                            // leave last overlay drawn; user can click again
                        };

                        // Start staleness check: clear overlay if no new data for 5 seconds
                        // This prevents stale overlays from showing when agent stops processing or is too slow
                        overlayStalenessCheckInterval = setInterval(() => {
                            if (overlayLastTimestamp) {
                                const now = Date.now();
                                const age = now - overlayLastTimestamp;
                                const STALE_THRESHOLD_MS = 5000;  // 5 seconds
                                
                                if (age > STALE_THRESHOLD_MS) {
                                    // Overlay is stale, clear it
                                    clearOverlayCanvas();
                                    overlayLastTimestamp = null;
                                }
                            }
                        }, 1000);  // Check every second

                        if (overlayBadge) {
                            overlayBadge.innerHTML = `<span class="fa-solid fa-robot me-1"></span>${escapeHtml(agentName || 'Agent')} overlay`;
                        }
                        if (switchToCameraBtn) {
                            switchToCameraBtn.classList.remove('d-none');
                        }
                    }

                    async function switchToAgentStream(agentId, agentName) {
                        if (!agentId) {
                            console.error('No agent ID provided');
                            return;
                        }

                        console.log('Selecting agent overlay:', agentId);
                        
                        // Update active agent highlight in list
                        document.querySelectorAll('.agent-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        const agentItem = document.querySelector(`[data-agent-id="${agentId}"]`);
                        if (agentItem) {
                            agentItem.classList.add('active');
                        }

                        // Keep camera stream running; only switch overlay WS
                        await openOverlayWsForAgent(agentId, agentName);
                    }

                    // Function to switch back to camera stream
                    async function switchToCameraStream() {
                        console.log('Clearing agent overlay');
                        
                        // Remove active highlight from all agents
                        document.querySelectorAll('.agent-item').forEach(item => {
                            item.classList.remove('active');
                        });

                        closeOverlayWs();
                        clearOverlayCanvas();
                        selectedAgentId = null;
                        if (overlayBadge) {
                            overlayBadge.innerHTML = '<span class="fa-solid fa-eye me-1"></span>Live preview';
                        }
                        if (switchToCameraBtn) {
                            switchToCameraBtn.classList.add('d-none');
                        }
                    }

                    // Add click handler for switch to camera button
                    switchToCameraBtn?.addEventListener('click', () => {
                        switchToCameraStream();
                    });

                    // Reload button - reloads current stream (camera or agent)
                    document.getElementById('camera-reload')?.addEventListener('click', () => {
                        if (livePlayer && typeof livePlayer.destroy === 'function') {
                            livePlayer.destroy();
                            livePlayer = null;
                        }
                        // Reload camera stream (video always stays camera in Option A)
                        initLivePlayer();
                        // If an agent overlay is selected, re-open overlay WS
                        if (selectedAgentId) {
                            const agentItem = document.querySelector(`[data-agent-id="${selectedAgentId}"]`);
                            const agentName = agentItem?.querySelector('.name')?.textContent || 'Agent';
                            openOverlayWsForAgent(selectedAgentId, agentName);
                        }
                        loadAgentsForCamera().catch(() => {});
                    });

                    // Handle fullscreen changes to ensure canvas overlay is properly positioned
                    function handleFullscreenChange() {
                        if (!overlayCanvas || !videoEl) return;
                        
                        // Check if video is in fullscreen (support all browser prefixes)
                        const isFullscreen = document.fullscreenElement === videoEl || 
                                           document.webkitFullscreenElement === videoEl ||
                                           document.mozFullScreenElement === videoEl ||
                                           document.msFullscreenElement === videoEl;
                        
                        if (isFullscreen) {
                            // Store original parent if not already stored
                            if (!originalCanvasParent) {
                                originalCanvasParent = overlayCanvas.parentNode;
                                originalCanvasNextSibling = overlayCanvas.nextSibling;
                            }
                            
                            // Move canvas to body so it can overlay the fullscreen video
                            document.body.appendChild(overlayCanvas);
                            
                            // Function to position and size canvas to match video's displayed area
                            const updateCanvasPosition = () => {
                                const rect = videoEl.getBoundingClientRect();
                                overlayCanvas.style.position = 'fixed';
                                overlayCanvas.style.top = rect.top + 'px';
                                overlayCanvas.style.left = rect.left + 'px';
                                overlayCanvas.style.width = rect.width + 'px';
                                overlayCanvas.style.height = rect.height + 'px';
                                overlayCanvas.style.zIndex = '2147483647'; // Maximum z-index to ensure it's on top
                                overlayCanvas.style.pointerEvents = 'none'; // Ensure it doesn't block video controls
                            };
                            
                            // Initial positioning
                            updateCanvasPosition();
                            
                            // Resize and redraw after a short delay to ensure fullscreen is fully active
                            setTimeout(() => {
                                updateCanvasPosition(); // Update position again after fullscreen settles
                                resizeOverlayCanvasToVideo();
                                // If we have overlay data, trigger a redraw by calling drawOverlay with last data
                                if (window.__visionaiLastOverlayPayload) {
                                    drawOverlay(window.__visionaiLastOverlayPayload);
                                }
                            }, 150);
                            
                            // Store update function for resize events
                            window.__visionaiUpdateCanvasPosition = updateCanvasPosition;
                        } else {
                            // When exiting fullscreen, restore canvas to its original position
                            if (originalCanvasParent) {
                                if (originalCanvasNextSibling) {
                                    originalCanvasParent.insertBefore(overlayCanvas, originalCanvasNextSibling);
                                } else {
                                    originalCanvasParent.appendChild(overlayCanvas);
                                }
                                originalCanvasParent = null;
                                originalCanvasNextSibling = null;
                            }
                            
                            // Clear the update function
                            window.__visionaiUpdateCanvasPosition = null;
                            
                            // Restore original CSS positioning (will use CSS class styles)
                            overlayCanvas.style.position = '';
                            overlayCanvas.style.top = '';
                            overlayCanvas.style.left = '';
                            overlayCanvas.style.width = '';
                            overlayCanvas.style.height = '';
                            overlayCanvas.style.zIndex = '';
                            
                            // Resize and redraw after exiting fullscreen
                            setTimeout(() => {
                                resizeOverlayCanvasToVideo();
                                if (window.__visionaiLastOverlayPayload) {
                                    drawOverlay(window.__visionaiLastOverlayPayload);
                                }
                            }, 150);
                        }
                    }
                    
                    // Listen for fullscreen changes (all browser prefixes)
                    document.addEventListener('fullscreenchange', handleFullscreenChange);
                    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
                    document.addEventListener('MSFullscreenChange', handleFullscreenChange);
                    
                    // Also handle resize events when in fullscreen
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            const isFullscreen = document.fullscreenElement === videoEl || 
                                               document.webkitFullscreenElement === videoEl ||
                                               document.mozFullScreenElement === videoEl ||
                                               document.msFullscreenElement === videoEl;
                            if (isFullscreen) {
                                // Update canvas position to match video
                                if (window.__visionaiUpdateCanvasPosition) {
                                    window.__visionaiUpdateCanvasPosition();
                                }
                                resizeOverlayCanvasToVideo();
                                if (window.__visionaiLastOverlayPayload) {
                                    drawOverlay(window.__visionaiLastOverlayPayload);
                                }
                            }
                        }, 100);
                    });
                    
                    // Also listen for video element resize (for aspect ratio changes in fullscreen)
                    if (window.ResizeObserver) {
                        const videoResizeObserver = new ResizeObserver(() => {
                            const isFullscreen = document.fullscreenElement === videoEl || 
                                               document.webkitFullscreenElement === videoEl ||
                                               document.mozFullScreenElement === videoEl ||
                                               document.msFullscreenElement === videoEl;
                            if (isFullscreen && window.__visionaiUpdateCanvasPosition) {
                                window.__visionaiUpdateCanvasPosition();
                                resizeOverlayCanvasToVideo();
                                if (window.__visionaiLastOverlayPayload) {
                                    drawOverlay(window.__visionaiLastOverlayPayload);
                                }
                            }
                        });
                        if (videoEl) {
                            videoResizeObserver.observe(videoEl);
                        }
                    }

                    // Collapse/expand agent sidebar (persists)
                    const SIDEBAR_KEY = 'visionai.cameraDetail.sidebarCollapsed.v1';
                    const btnSidebar = document.getElementById('toggle-agent-sidebar');
                    function setSidebarBtnIcon() {
                        const icon = btnSidebar?.querySelector('span');
                        if (!icon || !shellEl) return;
                        const collapsed = shellEl.classList.contains('visionai-sidebar-collapsed');
                        icon.className = collapsed ? 'fa-solid fa-angles-right' : 'fa-solid fa-angles-left';
                    }
                    function setSidebarCollapsed(nextCollapsed) {
                        if (!shellEl) return;
                        shellEl.classList.toggle('visionai-sidebar-collapsed', !!nextCollapsed);
                        localStorage.setItem(SIDEBAR_KEY, nextCollapsed ? 'true' : 'false');
                        setSidebarBtnIcon();

                        // Timeline is always visible under the camera; no extra toggling needed.
                    }
                    // restore state (use the same path as user click so timeline + scroll behave consistently)
                    if (shellEl) {
                        const saved = localStorage.getItem(SIDEBAR_KEY) === 'true';
                        setSidebarCollapsed(saved);
                    }
                    btnSidebar?.addEventListener('click', () => {
                        const collapsed = shellEl?.classList.contains('visionai-sidebar-collapsed');
                        setSidebarCollapsed(!collapsed);
                    });

                    // Agent filtering (tabs + search)
                    const listEl = document.getElementById('agent-list');
                    const searchEl = document.getElementById('agent-search');
                    let activeFilter = 'active';

                    function escapeHtml(s) {
                        return String(s ?? '')
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#39;');
                    }

                    function mapAgentStatus(status) {
                        const s = String(status || '').toUpperCase();
                        if (s === 'SCHEDULED') return 'scheduled';
                        if (s === 'COMPLETED') return 'completed';
                        return 'active'; // ACTIVE + unknown -> active
                    }

                    function formatTimeLabel(agent) {
                        const uiStatus = mapAgentStatus(agent?.status);
                        if (uiStatus === 'completed') return 'Done';
                        if (uiStatus === 'active') return 'Now';

                        // scheduled: show start time if available
                        const start = agent?.start_time;
                        if (!start) return 'Scheduled';
                        try {
                            const d = new Date(start);
                            if (!isNaN(d.getTime())) {
                                return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            }
                        } catch {
                            // ignore
                        }
                        return 'Scheduled';
                    }

                    function buildAgentMessage(agent) {
                        const model = agent?.model ? String(agent.model) : '';
                        const fps = agent?.fps ? `FPS ${agent.fps}` : '';
                        const runMode = agent?.run_mode ? String(agent.run_mode) : '';
                        const rulesCount = Array.isArray(agent?.rules) ? `${agent.rules.length} rule(s)` : '';

                        // Pick the first non-empty bits
                        const parts = [model, runMode, rulesCount, fps].filter(Boolean);
                        return parts.length ? parts.join(' • ') : '—';
                    }

                    function renderAgentList(agents) {
                        if (!listEl) return;

                        // Clear existing
                        listEl.innerHTML = '';

                        if (!agents || !Array.isArray(agents) || agents.length === 0) {
                            const li = document.createElement('li');
                            li.className = 'nav-item';
                            li.innerHTML = '<div class="text-body-tertiary fs-9 p-3">No agents assigned to this camera.</div>';
                            listEl.appendChild(li);
                            return;
                        }

                        const avatarPool = [
                            '../assets/img/team/20.webp',
                            '../assets/img/team/25.webp',
                            '../assets/img/team/29.webp',
                            '../assets/img/team/30.webp'
                        ];

                        agents.forEach((agent, idx) => {
                            const uiStatus = mapAgentStatus(agent?.status);
                            const name = escapeHtml(agent?.name || 'Agent');
                            const timeLabel = escapeHtml(formatTimeLabel(agent));
                            const message = escapeHtml(buildAgentMessage(agent));
                            const agentId = agent?.id || '';

                            const avatar = avatarPool[idx % avatarPool.length];
                            const onlineClass = uiStatus === 'active' ? 'status-online' : '';

                            const li = document.createElement('li');
                            li.className = `nav-item agent-item ${uiStatus}`;
                            li.setAttribute('data-agent-status', uiStatus);
                            li.setAttribute('data-agent-id', agentId);

                            li.innerHTML = `
                                <a class="nav-link d-flex align-items-center justify-content-center p-2 agent-link" href="#!" role="button" data-agent-id="${agentId}">
                                    <div class="avatar avatar-xl ${onlineClass} position-relative me-2 me-sm-0 me-xl-2">
                                        <img class="rounded-circle border border-2 border-light-subtle" src="${avatar}" alt="Agent" />
                                    </div>
                                    <div class="flex-1 d-sm-none d-xl-block">
                                        <div class="d-flex justify-content-between align-items-center">
                                            <h5 class="text-body fw-normal name text-nowrap mb-0">${name}</h5>
                                            <p class="fs-10 text-body-tertiary text-opacity-85 mb-0 text-nowrap">${timeLabel}</p>
                                        </div>
                                        <div class="d-flex justify-content-between">
                                            <p class="fs-9 mb-0 line-clamp-1 text-body-tertiary text-opacity-85 message">${message}</p>
                                        </div>
                                    </div>
                                </a>
                            `;

                            // Add click handler to switch to agent stream
                            const linkEl = li.querySelector('.agent-link');
                            linkEl.addEventListener('click', (e) => {
                                e.preventDefault();
                                switchToAgentStream(agentId, name);
                            });

                            listEl.appendChild(li);
                        });
                    }

                    async function loadAgentsForCamera() {
                        const camId = currentCameraId;
                        if (!camId || !listEl) return;

                        listEl.innerHTML = '<li class="nav-item"><div class="text-body-tertiary fs-9 p-3">Loading agents...</div></li>';

                        if (!window.visionAPI || !window.visionAPI.isAuthenticated || !window.visionAPI.isAuthenticated()) {
                            listEl.innerHTML = '<li class="nav-item"><div class="text-body-tertiary fs-9 p-3">Login required.</div></li>';
                            return;
                        }

                        try {
                            const agents = await window.visionAPI.listAgentsByCamera(camId);
                            // Keep latest agents for timeline grouping (active agents -> groups)
                            lastAgentsForCamera = Array.isArray(agents) ? agents : [];
                            renderAgentList(agents);
                            applyFilter();
                            // If timeline already exists, resync groups
                            syncTimelineGroupsFromAgents(lastAgentsForCamera);
                        } catch (e) {
                            console.error('Failed to load agents:', e);
                            listEl.innerHTML = '<li class="nav-item"><div class="text-danger fs-9 p-3">Failed to load agents.</div></li>';
                        }
                    }

                    function applyFilter() {
                        const q = (searchEl?.value || '').trim().toLowerCase();
                        listEl?.querySelectorAll('.agent-item').forEach((li) => {
                            const status = li.getAttribute('data-agent-status');
                            const name = li.querySelector('.name')?.textContent?.toLowerCase() || '';
                            const msg = li.querySelector('.message')?.textContent?.toLowerCase() || '';

                            const matchesStatus = status === activeFilter;
                            const matchesText = !q || name.includes(q) || msg.includes(q);

                            li.style.display = (matchesStatus && matchesText) ? '' : 'none';
                        });
                    }

                    document.querySelectorAll('[data-agent-filter]').forEach((tab) => {
                        tab.addEventListener('click', (e) => {
                            e.preventDefault();
                            document.querySelectorAll('[data-agent-filter]').forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                            activeFilter = tab.getAttribute('data-agent-filter') || 'active';
                            applyFilter();
                        });
                    });

                    searchEl?.addEventListener('input', applyFilter);
                    applyFilter();

                    // Agents are loaded from initCamera() once camera id is known.

                    // vis-timeline assets are loaded lazily so this page works in Electron static HTML.
                    // NOTE: for production builds, node_modules is excluded by electron-builder config,
                    // so you'll likely want to vendor these two files into /custom_js/vendor later.
                    function ensureLinkOnce(href) {
                        if (document.querySelector(`link[data-visionai="true"][href="${href}"]`)) return;
                        const link = document.createElement('link');
                        link.rel = 'stylesheet';
                        link.href = href;
                        link.setAttribute('data-visionai', 'true');
                        document.head.appendChild(link);
                    }

                    function fmtHHmm(d) { return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`; }
                    function getDayBounds() {
                        const start = new Date();
                        start.setHours(0, 0, 0, 0);
                        const end = new Date();
                        end.setHours(23, 59, 59, 999);
                        return { start, end };
                    }
                    function dateAtMinute(dayStart, minute) {
                        return new Date(dayStart.getTime() + (minute * 60_000));
                    }

                    const visContainer = document.getElementById('cctv-vis');
                    const zoomInBtn = document.getElementById('cctv-zoom-in');
                    const zoomOutBtn = document.getElementById('cctv-zoom-out');
                    const zoomLabel = document.getElementById('cctv-zoom-label');

                    const VIS_CSS_HREF = '../node_modules/vis-timeline/styles/vis-timeline-graph2d.min.css';
                    const VIS_JS_SRC = '../node_modules/vis-timeline/standalone/umd/vis-timeline-graph2d.min.js';

                    let timeline = null;
                    let nowInterval = null;
                    let lastPointerX = null;
                    const nowId = 'now';

                    function getVisGlobal() {
                        return window.vis || window.visTimeline || window['vis-timeline'] || null;
                    }

                    async function ensureVisLoaded() {
                        // Load base vis CSS (we override most classes in our stylesheet)
                        ensureLinkOnce(VIS_CSS_HREF);
                        await loadScriptOnce(VIS_JS_SRC);
                        return getVisGlobal();
                    }

                    // ------------------------------------------------------------
                    // Realtime timeline model (agents -> groups, events -> items)
                    // ------------------------------------------------------------
                    let lastAgentsForCamera = [];
                    let visLibRef = null;
                    let groupsDS = null;
                    let itemsDS = null;
                    const imageUrlCache = new Map(); // eventId -> objectURL

                    function getActiveAgents(agents) {
                        return (Array.isArray(agents) ? agents : []).filter(a => mapAgentStatus(a?.status) === 'active');
                    }

                    function buildGroupsFromAgents(visLib, agents) {
                        const active = getActiveAgents(agents);
                        const rows = active.map((a) => ({
                            id: String(a?.id || ''),
                            content: escapeHtml(a?.name || 'Agent')
                        })).filter(g => g.id);

                        // Fallback group so timeline isn't blank
                        if (!rows.length) {
                            rows.push({ id: '__no_agents__', content: 'No active agents' });
                        }
                        return new visLib.DataSet(rows);
                    }

                    function syncTimelineGroupsFromAgents(agents) {
                        if (!visLibRef || !groupsDS) return;
                        try {
                            groupsDS.clear();
                            const next = buildGroupsFromAgents(visLibRef, agents);
                            next.forEach((g) => groupsDS.add(g));
                        } catch {
                            // ignore
                        }
                    }

                    function parseEventDate(ts) {
                        if (!ts) return new Date();
                        const d = new Date(ts);
                        return Number.isFinite(d.getTime()) ? d : new Date();
                    }

                    function classifyEventClass(label) {
                        const t = String(label || '').toLowerCase();
                        if (t.includes('motion') || t.includes('movement')) return 'cctv-motion';
                        if (t.includes('record')) return 'cctv-recording';
                        return 'cctv-event';
                    }

                    function addTimelineItemFromNotificationPayload(payload) {
                        if (!itemsDS || !payload) return;
                        if (payload.type && payload.type !== 'event_notification') return;

                        const camId = payload?.agent?.camera_id || payload?.agent?.cameraId || '';
                        if (!camId || camId !== currentCameraId) return;

                        const agentId = String(payload?.agent?.agent_id || payload?.agent?.agentId || '');
                        if (!agentId) return;

                        // Only show if this agent is currently active (group exists)
                        const groupExists = !!groupsDS.get(agentId);
                        if (!groupExists) return;

                        const start = parseEventDate(payload?.event?.timestamp || payload?.received_at);
                        const durSec = Number(payload?.metadata?.duration_seconds || payload?.metadata?.duration_sec || 30);
                        const end = new Date(start.getTime() + (Math.max(5, durSec) * 1000));

                        const id =
                            String(payload?.event_id || payload?.metadata?.event_id || payload?.session_id || payload?.metadata?.session_id || '') ||
                            `${agentId}_${start.getTime()}`;

                        if (itemsDS.get(id)) return;

                        itemsDS.add({
                            id,
                            group: agentId,
                            start,
                            end,
                            type: 'range',
                            className: classifyEventClass(payload?.event?.label),
                            content: '',
                            // popup fields
                            label: String(payload?.event?.label || 'Event'),
                            severity: String(payload?.event?.severity || payload?.metadata?.severity || ''),
                            agentName: String(payload?.agent?.agent_name || payload?.agent?.agentName || ''),
                            cameraId: String(camId),
                            eventId: String(payload?.event_id || payload?.metadata?.event_id || ''),
                            hasImage: true,
                        });
                    }

                    // ------------------------------------------------------------
                    // Popup overlay using vis itemover/itemout
                    // ------------------------------------------------------------
                    const popupEl = document.getElementById('cctv-event-popup');
                    const popupImg = document.getElementById('cctv-event-popup-img');
                    const popupTitle = document.getElementById('cctv-event-popup-title');
                    const popupTime = document.getElementById('cctv-event-popup-time');
                    const popupAgent = document.getElementById('cctv-event-popup-agent');
                    const popupSev = document.getElementById('cctv-event-popup-sev');

                    function fmtTimeLocal(d) {
                        try {
                            const dt = d instanceof Date ? d : new Date(d);
                            return dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                        } catch {
                            return '--:--';
                        }
                    }

                    function positionPopup(clientX, clientY) {
                        if (!popupEl) return;
                        const pad = 12;
                        const w = popupEl.offsetWidth || 320;
                        const h = popupEl.offsetHeight || 120;
                        const vw = window.innerWidth || 1024;
                        const vh = window.innerHeight || 768;

                        let x = clientX + 14;
                        let y = clientY + 14;
                        if (x + w + pad > vw) x = clientX - w - 14;
                        if (y + h + pad > vh) y = clientY - h - 14;
                        x = Math.max(pad, Math.min(vw - w - pad, x));
                        y = Math.max(pad, Math.min(vh - h - pad, y));
                        popupEl.style.left = `${x}px`;
                        popupEl.style.top = `${y}px`;
                    }

                    function setPopupVisible(show) {
                        if (!popupEl) return;
                        popupEl.setAttribute('data-show', show ? 'true' : 'false');
                        popupEl.setAttribute('aria-hidden', show ? 'false' : 'true');
                    }

                    async function ensureEventThumb(eventId) {
                        if (!eventId) return null;
                        if (imageUrlCache.has(eventId)) return imageUrlCache.get(eventId);
                        if (!window.visionAPI || typeof window.visionAPI.fetchEventImageObjectUrl !== 'function') return null;
                        try {
                            const url = await window.visionAPI.fetchEventImageObjectUrl(eventId);
                            imageUrlCache.set(eventId, url);
                            return url;
                        } catch {
                            return null;
                        }
                    }

                    async function showPopupForItem(itemId, clientX, clientY) {
                        if (!itemsDS || !popupEl) return;
                        const it = itemsDS.get(itemId);
                        if (!it) return;

                        popupTitle.textContent = String(it.label || 'Event');
                        popupTime.textContent = fmtTimeLocal(it.start);
                        popupAgent.textContent = String(it.agentName || '—');
                        popupSev.textContent = String(it.severity || '—');

                        // image
                        if (popupImg) {
                            popupImg.style.display = 'none';
                            popupImg.removeAttribute('src');
                        }
                        const eventId = String(it.eventId || it.id || '');
                        const hasImage = it.hasImage !== false;
                        if (hasImage && eventId) {
                            const url = await ensureEventThumb(eventId);
                            if (url && popupImg) {
                                popupImg.src = url;
                                popupImg.style.display = 'block';
                            }
                        }

                        positionPopup(clientX, clientY);
                        setPopupVisible(true);
                    }

                    function hidePopup() {
                        setPopupVisible(false);
                    }

                    function updateZoomPill() {
                        if (!timeline || !zoomLabel) return;
                        const w = timeline.getWindow();
                        const mins = Math.round((w.end.getTime() - w.start.getTime()) / 60_000);
                        if (mins >= 24 * 60) zoomLabel.textContent = '24h';
                        else if (mins >= 6 * 60) zoomLabel.textContent = '6h';
                        else if (mins >= 60) zoomLabel.textContent = '1h';
                        else zoomLabel.textContent = `${mins}m`;
                    }

                    // Cursor anchored zoom for +/- buttons using setWindow.
                    // (Mouse wheel zoom remains vis-timeline's built-in cursor-anchored behavior.)
                    function zoomAtCursor(factor, anchorClientX) {
                        if (!timeline || !visContainer) return;
                        const { start: dayStart, end: dayEnd } = getDayBounds();
                        const w = timeline.getWindow();
                        const startMs = w.start.getTime();
                        const endMs = w.end.getTime();
                        const duration = Math.max(1, endMs - startMs);

                        const rect = visContainer.getBoundingClientRect();
                        const x = clamp((anchorClientX ?? (rect.left + rect.width / 2)) - rect.left, 0, rect.width);
                        const p = rect.width > 0 ? (x / rect.width) : 0.5;
                        const timeAtCursor = startMs + p * duration;

                        const newDuration = duration * factor;
                        let newStart = timeAtCursor - p * newDuration;
                        let newEnd = newStart + newDuration;

                        // Clamp to 24h day bounds
                        const minMs = dayStart.getTime();
                        const maxMs = dayEnd.getTime();
                        if (newStart < minMs) {
                            newStart = minMs;
                            newEnd = minMs + newDuration;
                        }
                        if (newEnd > maxMs) {
                            newEnd = maxMs;
                            newStart = maxMs - newDuration;
                        }
                        newStart = clamp(newStart, minMs, maxMs);
                        newEnd = clamp(newEnd, minMs, maxMs);

                        timeline.setWindow(new Date(newStart), new Date(newEnd), { animation: false });
                        updateZoomPill();
                    }

                    function updateNowMarker() {
                        if (!timeline) return;
                        const now = new Date();
                        try {
                            timeline.setCustomTime(now, nowId);
                            timeline.setCustomTimeMarker(`NOW ${fmtHHmm(now)}`, nowId);
                        } catch {
                            // ignore
                        }
                    }

                    async function initCctvTimeline() {
                        if (!visContainer) return;

                        const visLib = await ensureVisLoaded();
                        if (!visLib || !visLib.Timeline || !visLib.DataSet) {
                            console.warn('vis-timeline not available');
                            return;
                        }

                        // Prevent double init on SPA reinjection
                        if (timeline) return;

                        const { start: dayStart, end: dayEnd } = getDayBounds();
                        visLibRef = visLib;
                        groupsDS = buildGroupsFromAgents(visLib, lastAgentsForCamera);
                        itemsDS = new visLib.DataSet([]);

                        const options = {
                            // 24h bounds
                            min: dayStart,
                            max: dayEnd,
                            start: dayStart,
                            end: dayEnd,

                            // Interaction
                            moveable: true,
                            zoomable: true,
                            zoomKey: '', // allow wheel zoom without ctrl
                            selectable: false,
                            multiselect: false,
                            stack: false,

                            // Compact layout
                            height: 160,
                            margin: { item: 6, axis: 8 },
                            groupHeightMode: 'fixed',
                        };

                        timeline = new visLib.Timeline(visContainer, itemsDS, groupsDS, options);

                        // Custom NOW playhead (cyan). (Disable default current time marker)
                        try {
                            timeline.addCustomTime(new Date(), nowId);
                            timeline.setCustomTimeMarker(`NOW ${fmtHHmm(new Date())}`, nowId);
                        } catch {
                            // ignore
                        }

                        // Update NOW periodically
                        nowInterval = setInterval(updateNowMarker, 15_000);

                        // Zoom pill updates
                        timeline.on('rangechanged', updateZoomPill);
                        updateZoomPill();

                        // Track last pointer for +/- anchoring
                        visContainer.addEventListener('mousemove', (e) => { lastPointerX = e.clientX; });

                        zoomInBtn?.addEventListener('click', () => zoomAtCursor(0.7, lastPointerX));
                        zoomOutBtn?.addEventListener('click', () => zoomAtCursor(1.35, lastPointerX));

                        // Hook into existing cleanup to destroy timeline on SPA nav
                        const prevCleanup = window.__visionaiPageCleanup;
                        const onRawEvent = (ev) => addTimelineItemFromNotificationPayload(ev?.detail);
                        window.addEventListener('vision:event-notification-raw', onRawEvent);
                        // Popup interactions
                        let popupItemId = null;
                        timeline.on('itemover', async (props) => {
                            try {
                                popupItemId = props?.item || null;
                                const e = props?.event;
                                if (!popupItemId || !e) return;
                                await showPopupForItem(popupItemId, e.clientX, e.clientY);
                            } catch {
                                // ignore
                            }
                        });
                        timeline.on('itemout', () => {
                            popupItemId = null;
                            hidePopup();
                        });
                        timeline.on('mouseMove', (props) => {
                            if (!popupItemId) return;
                            const e = props?.event;
                            if (!e) return;
                            positionPopup(e.clientX, e.clientY);
                        });

                        window.__visionaiPageCleanup = () => {
                            try { prevCleanup?.(); } catch {}
                            try { window.removeEventListener('vision:event-notification-raw', onRawEvent); } catch {}
                            try { hidePopup(); } catch {}
                            try {
                                // Revoke cached object URLs
                                imageUrlCache.forEach((u) => {
                                    try { URL.revokeObjectURL(u); } catch {}
                                });
                                imageUrlCache.clear();
                            } catch {}
                            try { if (nowInterval) clearInterval(nowInterval); } catch {}
                            nowInterval = null;
                            try { timeline?.destroy?.(); } catch {}
                            timeline = null;
                            groupsDS = null;
                            itemsDS = null;
                            visLibRef = null;
                        };

                        async function listEventsPaged(range, totalLimit) {
                            const maxPageSize = 100; // backend likely validates max limit (avoid 422)
                            const desired = Math.max(0, Number(totalLimit || 0));
                            const all = [];
                            if (!window.visionAPI?.listEvents) return all;

                            for (let skip = 0; skip < desired; skip += maxPageSize) {
                                const limit = Math.min(maxPageSize, desired - skip);
                                const res = await window.visionAPI.listEvents(range, limit, skip);
                                const rows = Array.isArray(res?.items) ? res.items : [];
                                all.push(...rows);
                                if (rows.length < limit) break; // no more pages
                            }
                            return all;
                        }

                        // Initial history: load today's events and render them into agent lanes
                        // (DB-backed, so timeline isn't empty on load)
                        try {
                            if (window.visionAPI?.listEvents) {
                                const rows = await listEventsPaged('today', 500);
                                rows
                                    .filter(r => String(r?.camera_id || '') === String(currentCameraId || ''))
                                    .forEach((r) => {
                                        const agentId = String(r?.agent_id || '');
                                        if (!agentId) return;
                                        if (!groupsDS.get(agentId)) return; // only active agents
                                        const start = parseEventDate(r?.event_ts || r?.received_at);
                                        const end = new Date(start.getTime() + 30_000);
                                        const id = String(r?.id || `${agentId}_${start.getTime()}`);
                                        if (itemsDS.get(id)) return;
                                        itemsDS.add({
                                            id,
                                            group: agentId,
                                            start,
                                            end,
                                            type: 'range',
                                            className: classifyEventClass(r?.label),
                                            content: '',
                                            // popup fields
                                            label: String(r?.label || 'Event'),
                                            severity: String(r?.severity || ''),
                                            agentName: String(r?.agent_name || ''),
                                            cameraId: String(r?.camera_id || ''),
                                            eventId: String(r?.id || ''),
                                            hasImage: !!r?.has_image,
                                        });
                                    });
                            }
                        } catch {
                            // ignore history load failures (realtime will still work)
                        }
                    }

                    // Initialize after a short delay to ensure all dependencies are loaded
                    setTimeout(() => {
                        init().then(() => {
                            initCctvTimeline();
                        });
                    }, 500);
                })();
            </script>
        </div>
    </div>
</body>
</html>


